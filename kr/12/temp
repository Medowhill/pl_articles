람다 대수(lambda calculus)는 변수, 람다 요약, 함수 적용으로만 이루어진 언어이다. 이번 글에서는 람다 대수로 얼마나 많은 것을 할 수 있는지 알아본다.

## 문법

다음은 람다 대수의 요약 문법이다.

FAE와 달리 정수, 합, 차가 존재하지 않는다. 식은 변수이거나 람다 요약이거나 함수 적용이다. 값은 클로저만 가능하며 정숫값은 없다.

## 의미

람다 대수의 자연적 의미는 FAE와 동일하게 정의할 수 있다.

## Church 수

Church 수(Church numeral)는 자연수와 덧셈이나 곱셈 같은 자연수를 다루는 연산을 람다 대수로 인코딩 하는 방법이다. 편의상, AE에 두 식의 차 대신 두 식의 곱이 있다고 가정하고 AE를 람다 대수로 인코딩 하겠다. 우선 자연수를 인코딩 하는 방법부터 보자.

Church 수를 직관적으로 설명하면, 자연수 n은 어떤 함수로 인코딩 되며, 그 함수는 다른 함수를 인자로 받아, 그 함수를 n 번 반복해서 적용하는 함수를 결과로 낸다. 즉, mathit{encode}(n)=fmapsto f^n이다. 또한, 어떤 자연수 n과 함수 f가 있을 때, n f는 f^n이다.

Church 수가 말이 되는 이유는 합을 인코딩 함으로써 잘 드러난다.

어떤 자연수 n, m과 함수 f가 있을 때, (n+m) f는 lambda x.n f (m f x)인데, n f는 f^n, m f는 f^m이므로, lambda x.f^n (f^m x)와 같다. 이는 lambda x.f^{n+m} x, 즉 f^{n+m}과 같으므로, n+m은 fmapsto f^{n+m}이다. 따라서, mathit{encode} 함수가 합을 올바르게 인코딩 하였다.

비슷한 원리로 곱도 인코딩 할 수 있다.

어떤 자연수 n, m과 함수 f가 있을 때, (ntimes m) f는 n m f인데, m f는 f^m이므로, n f^m과 같다. 또한, n f는 f^n이므로, n f^m은   (f^m )^n 과 같다. ntimes m이 fmapsto f^{ntimes m}이므로 곱이 올바르게 인코딩 되었다.

뺄셈과 나눗셈도 람다 대수로 인코딩 할 수 있으며, 더 나아가 정수나 유리수 및 그에 대한 연산 역시 인코딩 할 수 있다. 이 글에서는 다루지 않는다.

## Church 불

Church 불(Church boolean)은 참과 거짓 및 조건식, 논리합, 논리곱 등을 람다 대수로 인코딩 하는 방법이다. 지금까지 정의한 언어에는 불 값이 존재하지 않았기에, 먼저 AE에 참, 거짓, 조건식을 추가한 BAE를 간단히 정의하겠다.

AE에 추가된 부분만 정의하였다. 메타변수 b는 불 값을 나타낸다.

조건이 참이면 참에 해당하는 가지의 식만 계산하고, 거짓이면 거짓에 해당하는 가지의 식만 계산한다.

먼저 참과 거짓을 인코딩 하는 방법을 보자.

_ 는 임의의 식이다. 인자를 사용하지 않을 것이기에 그 값이 중요하지 않아서 밑줄 문자로 표기하였다. lambda x.x 같은 식이 대신 써있다고 생각해도 된다.

자연수의 인코딩을 이해하기 위해서 합과 곱의 인코딩을 본 것처럼, 불 값의 인코딩을 이해하기 위해서는 조건식의 인코딩을 봐야 한다.

_ 는 매개변수가 사용되지 않는다는 것을 표현하기 위해 사용한 것으로, x 같은 매개변수 이름이 써있다고 생각해도 된다. e_1이 참을 나타낸다고 가정해보자. 그러면 전체 식은 lambda a.lambda b.a _  (lambda_ .mathit{encode}(e_2)) (lambda_ .mathit{encode}(e_3))이 되며, 이는 lambda_ .mathit{encode}(e_2) _ 와 같다. 따라서, mathit{encode}(e_2)를 계산한 결과와 같은 값을 나타내며, mathit{encode}(e_3)은 계산하지 않는다. 마찬가지로, e_1이 거짓을 나타낸다면, 전체 식은 mathit{encode}(e_3)을 계산한 결과와 같은 값을 나타내며, mathit{encode}(e_2)는 계산하지 않는다.

다음의 인코딩을 생각해보자.

기존의 인코딩보다 간단하지만, 참과 거짓 가지를 언제나 모두 계산한다는 문제가 있다. 이 글에서 정의한 람다 대수는 빠른 계산(eager evaluation)을 사용하며, 느린 계산(lazy evaluation)을 하도록 정의하였다면 두 번째 인코딩을 사용할 수 있다. 느린 계산에 관해서는 나중 글에서 다룬다.

이번에는 FAE에 textsf{if0}을 추가하여 CFAE를 정의해보자. textsf{if0}는 textsf{if}와 유사하지만, 조건이 불 값이 아닌 정숫값으로, 정수가 0이면 참 가지를 계산하고, 0이 아니면 거짓 가지를 계산한다.

FAE에 추가된 유일한 식인 조건식만 정의하였다.

BAE의 의미와 유사하게 조건식의 의미를 정의하였다.

textsf{if0}을 람다 대수로 인코딩 해보자. 간결함을 위해서, T를 lambda a.lambda b.a _  대신, F를 lambda a.lambda b.b _  대신 사용하겠다. Is0이 lambda n.n (lambda_ .F) T를 의미한다고 생각하자. n이 0이라면, Is0 n은 (lambda_ .F)^0 T이므로, T이다. 반대로, n이 1이 아니라면 lambda_ .F가 최소 한 번은 적용되므로, 결과가 F이다. 이를 바탕으로 textsf{if0}을 인코딩 할 수 있다.

## 람다 대수의 표현력

람다 대수는 얼마나 많은 것을 표현할 수 있을까? 람다 대수로 인코딩 할 수 있는 함수를 람다 계산 가능한(lambda computable) 함수라고 부른다. 유사하게, Turing 기계(Turing machine)로 구현 할 수 있는 함수를 Turing 계산 가능한(Turing computable) 함수라고 한다. 람다 계산 가능한 함수는 Turing 계산 가능하고, Turing 계산 가능한 함수는 람다 계산 가능한 함수임이 증명되어 있다. 따라서, Turing 기계로 구현할 수 있는 계산의 집합과 람다 대수로 인코딩 할 수 있는 계산의 집합은 같으며, 람다 대수가 Turing 완전(Turing complete)하다고 말할 수 있다. Turing 기계가 할 수 있는 계산은 현재의 컴퓨터가 할 수 있는 계산과 거의 같다. (컴퓨터의 메모리는 유한하지만 Turing 기계의 테이프는 무한하다.) 따라서, 람다 대수는 컴퓨터가 할 수 있는 모든 일을 표현하는 언어이며, 그런 의미에서 람다 대수는 ‘유일한’ 프로그래밍 언어이다.
