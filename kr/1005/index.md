### Taylor Subsumes Scott, Berry, Kahn and Plotkin
람다 함수의 도함수는 주어진 값에 따라 얼마나 결과가 바뀌는지 표현. Taylor 팽창을 할 수 있으며 구한 선형 근사 함수는 실행 시간과 연관되어 있음. 다양한 관련 선행 연구들이 있음. 다른 개념을 통해 증명한 람다 항의 성질들을 Taylor 팽창을 통해 간단한 개념을 바탕으로 다시 증명할 수 있음을 보임.

### Deductive Verification with Ghost Monitors
Hoare 논리와 같은 기존의 검증 방법들은 프로그램(과 이를 작성한 언어)의 문법에 크게 의존한다는 단점이 있음. 재귀 함수를 반복문을 통해 작성한 경우, 결과 검증은 불변 성질(invariant), 종료 증명은 변화 성질(variant)을 찾아야 하지만 이는 어려움. 이를 해결하고자 환영 모니터(ghost monitor) 도입. 원래의 코드에 중단점(breakpoint) 지정(기호 실행 등이 가능하도록). 재귀적인 형태로 환영 모니터 작성. 환영 모니터는 한 중단점부터 다음 중단점까지 실행. 환영 모니터가 명세를 따른다는 사실은 자동으로 검증할 수 있음. 환영 모니터를 작성하기 위한 언어도 제안.

### Dependent Type Systems as Macros
의존적 타입 언어는 구현하기 어려움. 그로 인해 연구자들이 다양한 의존적 타입 언어의 설계를 탐색해 보기 어려움. 이를 해결하고자 TURNSTILE+를 제시. TURNSTILE+는 TURNSTILE의 개선으로, 매크로 정의에 타입 검사를 추가하는 방식으로 정적 타입 언어를 구현할 수 있게 함. 의존적 타입을 지원하기 위해 여러 문제를 해결해야 했는데, 예를 들면 의존적 타입을 검사하기 위해서는 식을 계산할 필요가 있기에 매크로 팽창, 타입 검사, 식 계산이 번갈아 가며 일어날 수 있어야 하는 문제가 있었음.

### The Next 700 Relational Program Logics
관계적 성질(relational property)는 하나 또는 여러 프로그램의 여러 실행 사이의 관계를 설명함. 이는 프로그램의 동치 등 프로그램의 동작에 대한 다양한 성질을 증명하는 데 유용함. 지금까지 다양한 관계적 검증 도구가 제시되었으나 각각은 특정한 부작용에 한정되어 있다는 문제가 있음. 이를 해결하기 위해 임의의 모나드적 작용을 다룰 수 있는 프로그램 로직을 위한 일반적인 프레임워크를 제시함. 프레임워크의 규칙들은 세 종류로 나뉨: 작용 없는 순수한 구성 요소에 대한 규칙, return과 bind에 대한 규칙, 특정 작용에 관한 연산에 대한 규칙.

### Complexity and Information in Invariant Inference
불변 성질 추론은 검증에서 중요한 주제. SAT 쿼리를 통해 불변 성질을 추론하는 알고리즘이 널리 사용되어 옴. 이 논문은 SAT을 통한 불변 성질 추론의 점근적 복잡도를 탐구함. 불변 성질이 다항 길이인 경우만 고려. Hoare 쿼리 모델에 집중. 이 모델에서 추론 알고리즘은 대상 프로그램에 직접 접근하는 대신, 사전 조건과 사후 조건을 고르고 이 조건이 만족되는지 쿼리를 통해 확인함. 논문은, 어떤 일반화도 추론 알고리즘을 다항 개수의 쿼리만을 사용하게 만들 수는 없으며, {a}d{b} 형태의 검사를 하는 알고리즘이 {a}d{b} 형태의 검사만 하는 알고리즘에 비해 뛰어남을 밝힘.

### Actris: Session-Type Based Reasoning in Separation Logic
동시성 프로그래밍에서 메시지 전달 방식은 흔히 사용됨. 메시지 전달 방식이 단독으로 사용되는 경우는 드무며 대부분의 경우에 락과 같은 다른 기능들과 함께 사용됨. 메시지 전달 방식과 다른 기능들을 함께 사용하는 동시성 프로그램을 검증하는 것은 어려움. 이를 해결하고자 Actris를 도입. Actris는 Iris를 기반으로 하며, 의존적 분리 프로토콜을 도입함. 의존적 분리 프로토콜은 세션 타입과 유사하지만, 세션 타입이 타입에 대한 논증만 가능한 것에 비해 의존적 분리 프로토콜은 동시 분리 논리(concurrent separation logic)의 명제들을 통해 채널의 동작에 대한 정확한 묘사가 가능함.

### Formal Verification of a Constant-Time Preserving C Compiler
정형 검증된 컴파일러는 소스 코드의 의미를 보존한다는 것이 증명되어 있으나, 실행 성능이나 보안도 보존한다는 보장은 없음. 암호학적 상수 시간(cryptogarhpic constant-time) 성질은 프로그램이 비밀 데이터에 따라 가지를 선택하거나 메모리 접근을 결정하는 일이 없다는 것을 의미. 소스 코드가 암호학적 상수 시간을 만족하더라도 컴파일러가 이를 보존한다는 보장이 없음. 이 연구에서는 CompCert에서 암호학적 상수 시간을 보존하지 않는 단계를 찾고 이를 수정하였으며 그 결과 컴파일러가 암호학적 상수 시간을 보존함을 Coq으로 증명함.

### Coq Coq Correct! Verification of Type Checking and Erasure for Coq, in Coq
Coq의 핵심 언어를 위한 타입 검사기의 구현이 그에 대한 명세와 비교했을 때 올바름을 Coq으로 증명함. 이는 Coq의 무모순성을 Coq으로 증명한 것과는 다르므로 괴델의 불완전성 정리에 위배되지 않음. Coq의 무모순성을 가정한 채로 타입 검사기의 구현이 올바름을 증명한 것. 이를 통해 믿어야 하는 영역을 Coq의 구현으로부터 Coq의 이론으로 내렸다는 의의가 있음.

### Undecidability of D<: and Its Decidable Fragments
경로 기반 타입에 대한 대수인 DOT의 타입 검사는 결정 불가능한 것으로 여겨져 옴. 이전의 결정 불가능성 증명이 틀린 것을 밝혀 냄. DOT의 일부분인 D<:을 정의하고 이와 동치인 D<: 정규형(D<: normal form)을 정의하였으며 F<:-를 D<: 정규형으로 환원함으로써 D<:이 결정 불가능함을 보임. 결정 불가능성에는 ALL과 SR이라는 두 규칙이 핵심 역할을 하며, SR을 없애고 ALL을 제약해 만든 핵심 D<:(kernel D<:)이 결정 가능함을 보임. ALL의 제약을 완화하여 핵심 D<:보다 뛰어난 표현력을 가지는 강한 핵심 D<:(strong kernel D<:)을 정의하고 강한 핵심 D<: 역시 결정 가능함을 보임.

### Incorrectness Logic
사람들은 논증할 때 흔히 어떻게 잘못될 수 있는지, 즉 버그의 존재에 대해 이야기함. 이는 Hoare 논리가 버그의 부재를 증명하여 프로그램의 올바름을 증명하는 것과는 반대 방향임. 이 연구에서는 올바르지 않음 논리(incorrectness logic)를 제시함. Hoare 논리가 사전 조건을 만족하는 상태에서 코드가 실행되었을 때 도달할 수 있는 상태가 모두 만족하는 사후 조건을 제시한다면, 올바르지 않음 논리는 사전 조건을 만족하는 상태에서 코드가 실행되었을 때 사후 조건을 만족하는 상태는 모두 도달 가능하도록 사후 조건을 제시함. 이를 통해 버그의 존재를 증명할 수 있으며 이는 흔히 이루어지는 코드 리뷰 과정에서 중요함.

### Persistency Semantics of the Intel-x86 Architecture
비휘발성 메모리(non-volatile memory)는 전원이 꺼져도 데이터를 유지. 크래시가 발생한 이후에도 메모리의 데이터에 모순이 없음을 보장하기는 어려움. 영구성 모델(persistency model)은 영구 메모리(persistent memory)의 쓰기 순서를 규정하여 크래시 후에 올바르게 데이터를 복구할 수 있도록 함. 아직 x86 아키텍처를 위한 영구성 모델이 없음. 이 연구에서는 x86 아키텍처를 위한 Px86이라는 영구성 모델을 제안. Px86의 동작 중심(operational) 정의와 선언적(declarative) 정의를 모두 제시하였으며 둘이 동치임을 증명. 이를 바탕으로 영구적 라이브러리를 구현하고 그 구현이 바람직한 성질을 만족함을 증명.

### Program Synthesis by Type-Guided Abstraction Refinement
주어진 항들을 사용해 원하는 타입의 항을 합성하는 것은 어려움. 타입을 상태로 보고 주어진 부품(항)들을 상태에서 상태로의 이동(transition)으로 봄으로써 그래프를 만들면 합성 문제를 그래프에서의 경로 탐색 문제로 바꿀 수 있음. 이 방식은 다형 타입이 존재하면 잘 작동하지 않음. 이를 극복하고자 타입 유도 요약 정제(type-guided abstraction refinement)를 제안함. 이 알고리즘은 다형 타입이 존재해도 그래프가 유한하도록 타입을 근사해 요약 전이 네트워크(abstract transition network)를 만듦. 이 근사로 인해 경로 탐색 도중 잘못된 타입의 항으로 향할 수 있음. 이 경우 그래프를 정제하여 잘못된 타입의 항을 배제하고 올바른 타입의 항을 찾을 때까지 다시 탐색함.

### Reductions for Safety Proofs
프로그램 환원은 동시성/분산 프로그램의 올바름 논증을 간단하게 만들기 위해 사용됨. Lipton의 접근에 따르면 원자성(atomicity)을 가진 코드 블록을 찾아 그 블록 안에서는 순차적(sequential) 논증을 함으로써 증명을 간단하게 만들 수 있음. 한편, 메시지 전달 방식의 프로그램을 프로그램이 제한된 크기의 버퍼를 사용하도록 환원하여 증명을 간단하게 만들 수 있음. 이 연구에서는 증명 탐색과 프로그램 환원 탐색을 결합한 자동 검증 방법을 제안함.

### Deterministic Parallel Fixpoint Computation
요약 실행은 주어진 방정식 계(equation system)의 고정점을 찾음. 반복 전략은 고정점 계산 중에 방정식 계를 구성하는 식을 어떤 순서로 적용할지 정함. 일반적으로 사용되는 Bourdoncle의 알고리즘은 의존성 그래프에 대한 약한 위상 순서(weak topological order)를 바탕으로 반복 전략을 구함. 이 전략은 그래프로부터 전순서(total order)를 만들기에 순차적 알고리즘을 강제함. 이를 해결하고자 약한 부분 순서(weak partial order)를 도입함. 이를 바탕으로 한 반복 전략은 고정점을 동시 계산하는 것을 가능하게 하며 언제나 같은 결과를 냄. 이 결과는 Bourdoncle 알고리즘을 사용해 얻은 결과와 같음.

### Recurrence Extraction for Functional Programs through Call-by-Push-Value
프로그램의 실행 시간에 대한 점화식을 추출하고 그 해를 찾음으로써 프로그램의 복잡도를 구할 수 있음. 이 연구는 기존의 점화식 추출 과정을 개선. 중간 언어와 중간 언어를 위한 점화식 추출을 제안함으로써 소스 언어를 실행 시간을 보존하도록 중간 언어로 변환하면 점화식을 구할 수 있게 함. 중간 언어는 일반적인 재귀를 지원하는 값 밀기에 의한 호출(call-by-push-value) 언어이므로 소스 언어가 값에 의한 호출을 사용하든 이름에 의한 호출을 사용하든 상관없음.

### Towards Verified Stochastic Variational Inference for Probabilistic Programs
확률적 프로그래밍 언어는 변분 추론(variational inference) 알고리즘을 사용. 변분 추론 알고리즘은 모델의 사후 확률 분포를 추론하는 문제를 최적화 문제로 바꾼 뒤 경사 하강(gradient descent) 등을 통해 근사해를 구함. 이때 알고리즘은 모델에 대해 암묵적인 가정을 하며 모델이 이 가정에 부합하지 않을 시 최적화 목표가 정의되지 않거나 최적화가 수렴함이 보장되지 않음. 이 연구에서는 정적 분석을 통해 그런 가정이 만족되었는지 확인할 수 있도록 프로그램이 따랴아 할 규칙들을 제시. 이를 바탕으로 Pyro 언어에서 모델과 가이드가 조건을 만족하는지 검사하는 정적 분석기를 구현함.

### Fast, Sound, and Effectively Complete Dynamic Race Prediction
데이터 경쟁(data race)은 동시성 프로그램에서 공유 자원에 둘 이상이 동시에 접근할 때 발생하며, 오류의 원인이 되는 경우가 많음. 경쟁을 탐지하기 위한 여러 기술이 존재하며, 동적 경쟁 탐지 알고리즘은 프로그램을 한 번 실행하여 얻은 트레이스를 분석해 경쟁을 찾음. 흔히 사용되는 방식은 입력된 트레이스의 이벤트 사이의 부분 순서를 찾는 것. 기존의 부분 순서 알고리즘들은 경쟁 상태를 다 찾을 수 없음. 이 연구에서는 새로운 부분 순서를 도입하고 이를 바탕으로 알고리즘을 제시. 이 알고리즘은 두 개의 프로세스가 존재할 때 모든 경쟁을 찾으며 다항 시간에 실행됨.

### Par Means Parallel: Multiplicative Linear Logic Proofs as Concurrent Functional Programs
선형 논리(linear logic)은 동시성 프로그램의 타입 검사 및 논증에 사용될 수 있음. 기존의 시도들은 여러 한계가 있음. 이 연구에서는 다중 결론 자연 연역(multi-conclusion natural deduction)을 곱셈 선형 논리(multiplicative linear logic)에 채택하고 이와 동형인 동시성 대수를 제시. 이 대수는 자연스럽게 비동기적으로, 다양한 통신 패턴을 허용하며 교착 상태(deadlock)를 방지함.

### Trace Types and Denotational Semantics for Sound Programmable Inference in Probabilistic Languages
확률적 프로그래밍 언어는 일반적인 추론 알고리즘을 제공하나 알고리즘이 느리게 수렴한다는 문제가 있음. 일부 언어는 프로그램 가능한 추론(programmable inference)를 제공해 개발자들이 추론 알고리즘을 특정 모델이나 데이터에 맞추어 개선할 수 있게 함. 잘못된 추론 코드를 작성해 추론 알고리즘이 비정상적으로 종료되거나 잘못된 결과를 얻을 가능성 존재. 이 연구에서는 트레이스를 정확하게 묘사할 수 있는 타입 체계를 도입해 안전하게 추론을 프로그래밍할 수 있게 함.

### Virtual Timeline: A Formal Abstraction for Verifying Preemptive Schedulers with Temporal Isolation
실시간 시스템에는 실행 시간에 대한 보장이 필요. 시간적 격리(temproal isolation)는 시스템을 구성하는 각 구성의 부품이 다른 부품의 동작에 상관없이 시간 제약을 만족할 수 있어야 한다는 성질. 시간적 격리를 보장하는 스케줄러를 만들고 그 올바름을 증명하기는 어려움. 이 연구는 가상 타임라인(virtual timeline)을 도입해 시간적 격리를 보장하고 이를 증명.

### Relational Proofs for Quantum Programs
관계적 검증은 프로그램 실행 두 개에 대한 성질을 증명. 이 연구에서는 양자 프로그래밍 언어를 위한 관계적 프로그램 논리를 제안. 관계적 논리를 만드는 데 있어 중요한 것은 관심있는 성질을 잘 표현하도록 판단의 해석을 정의하는 것. 확률적 커플링(probabilisitic coupling)이 도움이 되지만 양자 얽힘으로 인해 어려움이 생김. 해석이 정의되고 나면 유용한 증명 규칙들을 찾아야 함. 다른 논리의 일반적인 규칙들은 양자 컴퓨팅에서 건전하지 않기 때문에 이 과정은 어려움.

### Seminaïve Evaluation for a Higher-Order Functional Language
Datalog는 기본적으로 유한 집합만 다루기 때문에 다양한 곳에 활용되기 위해서는 각각의 경우마다 수고를 들여 확장해야 함. 이를 해결하는 방법은 Datalog의 성질을 유지하면서도 확장을 만들기 쉬운 언어를 찾는 것. Datafun은 함수형 프로그래밍의 개념들을 Datalog와 함께 사용할 수 있게 하나, Datalog의 구현 기술들을 Datafun에 적용하기 어려운 경우가 많음. Datalog 구현의 핵심 중 하나는 반순진한 계산(semi-naive evaluation)으로, 고정점을 계산할 때 매 반복마다 모든 값을 새로 계산하는 대신 각 반복의 다른 부분만을 안전하게 근사하여 계산. 이 연구에서는 반순진한 계산을 Datafun의 고차 함수들과 함께 사용할 수 있게 함.

### CompCertM: CompCert with C-Assembly Linking and Lightweight Modular Verification
CompCert는 어셈블리가 포함된 코드를 지원하지 못함. 이를 해결하고자 CompCertX와 CompComp라는 CompCert의 확장 두 개가 이전에 제안되었음. CompCertX는 주어진 모듈 사이에 상호 의존성이 없고 각 모듈이 특정 명세를 따른다는 가정을 한다는 한계가 있음. ComComp는 CompCertX와 같은 제한이 없는 대신 증명에 훨씬 더 많은 비용이 필요. 이 연구에서는 CompComp와 같이 일반적인 경우에 사용할 수 있으면서도 CompCertX처럼 적은 비용으로 증명이 가능한 CompCertM을 제안. CompCertX의 핵심은 임의의 열린 시뮬레이션(open simultation)을 결합할 수 있는 자기연관문맥하 정제(RUSC; refinement under self-related contexts)임.

### Liquidate Your Assets: Reasoning about Resource Usage in Liquid Haskell
Liquid Haskell은 Haskell 타입 체계의 확장으로, 정제 타입을 통해 논리적 성질들을 표현하여 프로그램에 대해 논증하는 것을 가능하게 함. 프로그램 실행 시에 필요한 자원의 양을 추정하는 것은 중요한 문제. 이 연구에서는 Liquid Haskell의 타입 체계를 활용해 Haskell 프로그램의 자원 사용량의 한계를 정적으로 증명할 수 있게 함. 이 방법은 비용 분석이 올바르다는 것을 증명하기 쉽고 복잡한 불변 성질들이 타입 체계 안에서 표현되고 자동으로 검증될 수 있다는 장점을 가짐.

### Proving Expected Sensitivity of Probabilistic Programs with Randomized Variable-Dependent Termination Time
계의 연속성(continuity)은 출력의 변화가 입력의 변화에 대한 단조 함수임을 뜻함. 프로그램 민감도(program sensitivity)는 어떤 상수 L로, 입력이 x만큼 변할 때 출력은 최대 Lx만큼 변한다는 것을 뜻함. 확률적 프로그램에 대해서는 프로그램 민감도 기댓값을 고려할 수 있음. 기존 연구에서는 고정된 횟수의 반복만 가능한 확률적 프로그램의 민감도 기댓값을 구함. 이 연구에서는 입력에 따라 무작위로 결정된 횟수만큼 반복하는 확률적 프로그램의 민감도 기댓값을 구하는 방법을 제시. 이 방법은 슈퍼 마팅게일 순위(RSM; ranking supermartingale)에 기반함. 조건문이 포함된 프로그램에 대해서는 사용할 수 없다는 한계가 있음.

### Parameterized Verification under TSO is PSPACE-Complete
매개화된 시스템(parametrized system)은 임의 개수의 동일한 동시성 프로세스로 구성. 매개화된 시스템의 올바름을 확인하는 것이 매개화된 검증(parametrized verification). 순차적 일관성(sequential consistency)하의 매개화된 검증에 대한 기존 연구 존재. 현대에는 최적화를 위해 순차적 일관성보다 많은 동작을 허용하는 약한 메모리 모델을 사용. 이 연구에서는 전체 저장 순서(TSO; total store order)하에서 매개화된 검증 문제의 복잡도를 밝힘. 전체 저장 순서하에서는 제한 없는 수의 쓰기가 버퍼에 저장될 수 있으며, 버퍼에 저장된 쓰기는 메모리에 반영되기 전에는 다른 프로세스에 의해 관찰되지 않음. 프로그램 자체가 유한한 개수의 상태만 가질지라도 시스템은 무한한 수의 상태를 가질 수 있음. 중심점 요약(pivot abstraction)을 제안하고 이를 바탕으로 매개화된 시스템의 도달 가능성 문제가 PSAPCE 완전임을 보임.

### The Weak Call-by-Value λ-Calculus Is Reasonable for Both Time and Space
P, NP, PSACE, EXP 등의 복잡도 모임은 튜링 기계를 바탕으로 정의됨. 튜링 기계는 구성적(compositional)이지 않고 논증하기 어려움. 람다 대수는 여러 귀납적 데이터 타입을 표현하고 논증하기에 적합. 튜링 기계에서의 복잡도가 람다 대수에서의 복잡도와 같도록 람다 대수의 복잡도를 정의하기 어려움. 합리적인 기계는 서로를 다항 시간만큼의 부하만 상수 크기만큼의 공간 부하만을 추가한 채로 서로를 시뮬레이션할 수 있어야 하며, 이 경우 두 기계에서의 복잡도가 같아짐. 기존 연구에서는 완전 람다 대수의 베타 환원 수를 세면 시간 복잡도가 합리적임을 보임. 이 연구에서는 약한 값에 의한 호출 람다 대수의 베타 환원 수를 세고 가장 큰 항의 크기를 구하면 시간과 공간 복잡도 모두가 합리적임을 보임. 이 증명의 핵심은 람다 대수를 시뮬레이션 하는 두 전략을 교차로 사용하는 것.

### Abstract Extensionality: On the Properties of Incomplete Abstract Interpretations
두 프로그램이 같은 입력에 대해 같은 출력을 내면 외연적으로 동치(extensionally equivalent). 요약 실행은 프로그램의 의미를 근사함으로써 프로그램의 성질을 알아냄. 요약 실행은 일반적으로 불완전. 외연적 의미가 같은 프로그램이 다른 요약 의미를 가질 수 있고, 외연적 의미가 다른 프로그램이 같은 요약 의미를 가질 수 있음. 임의의 비자명한 요약을 기준으로 한 동치에 따라 만들어진 동치 모임(equivalence class)은 외연적 동치에 대해 닫혀 있지 않음을 증명함. 또한, 임의의 비자명한 유한 변수(varaible finite) 요약을 사용했을 때 요약 실행이 불완전한 프로그램의 모임은 튜링 완전함을 증명함.

### What Is Decidable about Gradual Types?
점진적 타입 언어를 사용하는 프로그래머는 Dyn이 사용된 프로그램에서 Dyn을 줄이는 방향으로 프로그램을 개선해 나감. 이 과정에서 중요한 결정 문제 네 개를 제시. 개선이 가능한가? 최대 타입 표시가 존재하는가? 극대 타입 표시가 존재하는가? 가능한 타입 표시가 유한한가? 각각을 푸는 알고리즘을 제시하고 그 복잡도를 구함. 개선 가능성은 O(n^2), 최대 존재성과 유한성은 EXPTIME, 극대 존재성은 NP 난해 문제임.

### Decomposition Diversity with Symmetric Data and Codata
표현 문제(the expression problem)는 프로그램의 분해가 함수형 언어에서처럼 객체들이 만들어진 방법에 의해 결정되어야 하는지, 아니면 객체 지향 언어에서처럼 객체들이 소멸되는 방법에 의해 결정되어야 하는지에 대한 공학적 거래를 묘사. 생성자에 중심을 두면 패턴 대조를 통해 새로운 소비자를 정의하기는 쉬우나 생성자를 추가할 수 없으므로 새로운 생산자를 정의하기 어려움. 소멸자에 중점을 두면 그 반대. 기존의 언어에는 둘 중 하나만 지원하며, 프로그래머는 이에 따라야 함. 이 연구에서는 비함수화(defunctionalization)와 재함수화(refunctionalization)을 일반화해 생성자화(constructorization)와 소멸자화(destructorization)를 제안하고 이를 바탕으로 두 가지 프로그래밍 패러다임을 대칭적으로 제공하는 언어를 제시.

### Reduction Monads and Their Signatures
람다 대수의 수학적 구조에 대한 시각은 항이 꼭지점이고 방향 환원이 모서리인 방향 다중그래프로 보는 것과 치환을 바탕으로 모나드로 보는 두 가지가 있음. 이 연구에서는 두 시각을 결합하는 새로운 방법인 환원 모나드(reduction monad)를 제안.

### The High-Level Benefits of Low-Level Sandboxing
신뢰할 수 없는 코드는 신뢰할 수 있는 프로그램에 보안 문제를 초래. 강건한 안전성(robust safety)는 프로그램의 안전성이 임의의 신뢰할 수 없는 코드와 연결되어 함께 실행되었을 때도 보장된다는 성질. 신뢰할 수 있는 코드와 없는 코드를 함께 실행하기 위한 일반적인 기술은 샌드박싱. 기존 연구는 샌드박싱을 통해 메모리 분리와 같은 성질을 얻을 수 있음을 보였으나, 샌드박싱을 통해 처음부터 끝까지 논증하는 것에 대한 이해가 부족. 이 연구에서는 샌드박싱이 강건한 안전성을 보장하므로 신뢰할 수 없는 코드의 동작을 고려하지 않고도 신뢰할 수 있는 코드의 안전성을 검증할 수 있음을 보임. 이를 위해 샌드박싱이 내장된 연산 의미를 정의. 고급 타입과 타입 any 사이의 변환을 허용하는 포장(wapper)을 설계하고 검증함.

### Spy Game: Verifying a Local Generic Solver in Iris
최소 고정점을 찾는 문제는 다양한 영역에서 발생. 이 연구에서는 최적 최소 고정점(optimal least fixed point)를 정의하고 모든 단조 함수에서 유일하게 존재함과 최소 고정점이 존재한다면 그와 같음을 증명함. 고정점을 찾는 여러 알고리즘이 존재. 알고리즘은 모든 변수에 대한 해를 찾는 대신에 필요에 따라, 증대하면서, 값을 기록하면서 작동. 이를 위해 사용자가 제공한 구현에 존재하는 변수 사이의 의존성을 동적으로 밝힘. 알고리즘의 명세는 순수하나 내부적으로는 수정 가능한 상태를 사용. 이 연구에서는 Iris를 사용해 기존 알고리즘의 안전함(허용되지 않는 메모리 접근과 경쟁 상태의 부재)과 올바름(주어진 함수의 최적 최소 고정점을 계산)을 증명. 이 과정에서 Iris의 예언 변수(prophecy variable)를 사용하고 예언 변수 API를 개선.

### RustBelt Meets Relaxed Memory
RustBelt 프로젝트의 기존 연구는 Rust의 안전성을 증명. 이 증명은 순차적 일관성을 가정했다는 한계가 있음. 현실에서는 관대한 메모리 모델(relaxed memory model)을 사용. 이 연구에서는 관대한 메모리하에서 Rust의 안전성을 증명. 기존의 증명은 순차적 일관성하에서만 사용 가능한 증명 규칙을 사용했기에 관대한 메모리에서는 불건전. 새로운 증명을 위해 기존에 있던 iGPS라는 관대한 메모리 분리 논리를 확장해 iRC11을 정의하고 이를 사용해 관대한 메모리하에서 Rust의 안전성을 증명. 증명을 위해 동기화된 유령 상태(synchronized ghost state)라는 새로운 개념을 제안. 증명 중 기존 Rust 라이브러리 구현에서 경쟁 상태가 발생하는 버그를 발견하고 고침.

### Deciding Memory Safety for Single-Pass Heap-Manipulating Programs
프로그램이 모든 표명(assertion)을 모든 가능한 입력과 실행에서 만족함을 자동으로 검증하는 문제는 일반적으로 불변 성질 등을 사용자가 작성해야 풀 수 있음. 그런 표시 없이 검증하는 것이 언제 결정 가능한지는 잘 알려져 있지 않음. 해석되지 않은 프로그램에 대한 기존 연구를 바탕으로, 이 연구에서는 포인터를 해석되지 않은 단항 함수로 보고 힙을 모델링함. 갱신 가능한 맵을 다루기 위해서는 별명 인식(alias awareness)가 필요함을 제시. 별명 인식은 두 포인터가 같은지 알려져 있다는 성질. 별명 인식을 만족하는 프로그램의 검증은 결정 가능함을 증명. 이를 메모리 안전성 검증에 응용 가능. 시작할 때 힙에 숲 데이터 구조만 존재하며, 데이터 구조를 한 번만 사용(스트리밍 일관성)하는 프로그램의 메모리 안전성 검증은 결정 가능하며 PSPACE 임을 증명. 스트리밍 일관성을 검사하는 것 역시 결정 가능.

### Optimal Approximate Sampling from Discrete Probability Distributions
이산 확률 분포로부터의 샘플링은 여러 분야에서 중요. 샘플링 알고리즘은 효율(샘플을 만들기 위해 소모하는 비트 수)적이고 정확(원하는 확률 분포와 만들어진 샘플 사이의 오차)해야 함. 이 연구에서는 샘플링 알고리즘을 세 기준으로 평가. 최적 근사 샘플링을 위한 새로운 알고리즘을 제안.

### Aiming Low Is Harder: Induction for Lower Bounds in Probabilistic Program Verification
확률적 프로그램에서 프로그램이 종료되었을 때 특정 확률 변수의 기댓값에 대해 논증하는 것은 중요한 검증 문제. 확률적 반복문을 검증할 때, 간단한 재귀 규칙이 기댓값의 상한을 구하는 데 사용. 규칙에 따르면 Phi(I) <= I이면 lfp Phi <= I임. 하한에 대한 비슷한 규칙은 불건전함. 건전한 규칙을 위해서는 부수 조건이 필요. I <= Phi(I)이고 어떤 조건을 만족하면 I <= lfp Phi임. 이 연구에서는 상대적으로 간단한 부수 조건을 제시. 실행 시간의 기댓값의 하한을 구하는 문제 역시 중요. 재귀적 하한 규칙이 실행 시간 기댓값으로 어떻게 이어지는지 보임.

### A Simple Differentiable Programming Language
자동 미분(automatic differentiation)은 프로그램으로 기술된 함수의 도함수를 계산하는 기술. 이 기술은 프로그램의 기본 연산에 대한 도함수와 미적분학의 연쇄 법칙에 의존. 프로그램에는 흐름 제어 요소나 계산 효과 등이 있으며 이를 어떻게 다룰지는 미적분학이 답을 주지 않음. 자동 미분의 구현은 코드 변형에 의존하는 방법과 트레이싱이 의존하는 방법이 있으며 트레이싱 기반 미분의 중요도가 커지고 있음. 조건문을 사용하는 프로그램의 미분을 올바르게 하기 어려움. 이 연구에서는 이를 부분 함수를 통해 해결. 조건문, 재귀 함수 등을 제공하는 일차 언어를 정의하고 트레이싱 기반 미분을 표현하는 연산 의미(operational semantics)를 제시. 해석학과 도메인 이론을 바탕으로 표시 의미(denotational semantics)를 제시하고 두 의미가 일치함을 증명.

### PλωNK: Functional Probabilistic NetKAT
이 연구에서는 함수형 확률적 네트워크 프로그래밍 언어인 PλωNK를 제시. 이는 컴퓨터 네트워크와 j네트워크 프로토콜을 모델링하고 그 성질을 검증하는 데 사용될 수 있음. 복잡한 프로그램을 쉽게 작성할 수 있도록 고차 함수를 지원. 인자의 부작용이 일어나는 시점이 명확하도록 값 밀기에 의한 호출과 유사한 방식을 도입. 확률적 언어의 표시 의미는 대개 측도론(measure theory)을 사용하나 측도론은 고차 함수를 지원하지 않으므로 준Borel 공간(quasi-Borel space)을 도메인으로 사용해 표시 의미를 정의. 특정 제약 조건하에서는 표시 의미를 근사하는 과정이 존재함을 보였으며 특정 제약 조건하에서는 프로그램의 동치가 결정 가능할 것임을 추측.

### Partial Type Constructors: Or, Making Ad Hoc Datatypes Less Ad Hoc
함수형 언어는 타입 생성자(type constructor)가 전함수(total function)라고 가정. 그러나 실제로는 어떤 데이터 타입은 타입 생성자가 부분 함수여야 하는 경우가 있음. 이 연구에서는 부분 타입 생성자를 지원하는 타입 체계를 설계. 부분 타입 생성자를 가지는 표면 언어를 컴파일 할 수 있는 타입 생성자가 전함수인 내부 언어를 제시했으며 표면 언어에서 통과된 프로그램은 컴파일 후에 내부 언어에서도 통과됨을 증명. 실제 Haskell 코드에 적용하여 적은 수의 타입 표시만으로 사용 가능함을 확인.

### Stacked Borrows: An Aliasing Model for Rust
Rust 타입 체계는 두 &mut이 가리키는 대상이 다를 것을 보장. unsafe를 사용한 코드에서는 이 가정이 성립하지 않을 수 있음. 컴파일러는 &mut의 유일성을 바탕으로 다양한 최적화를 할 수 있음. 두 &mut이 가리키는 대상을 같게 만드는 unsafe 코드가 정의되지 않은 동작(undefined behavior)을 일으킨다고 의미를 정의함으로써 해결 가능. 이 연구에서는 Rust의 별명에 대한 규칙을 강제하는 연산 의미인 빌리기 스택(stacked borrows)을 제시. 이 의미가 너무 많은 정의되지 않은 동작을 유발하지 않는다는 사실을 Rust 표준 라이브러리를 실험해 확인했으며, 이 의미가 다양한 컴파일러 최적화의 올바름을 보장한다는 사실을 증명.

### Abstract Interpretation of Distributed Network Control Planes
네트워크 실패는 큰 피해를 야기. 기존의 여러 네트워크 분석 연구는 네트워크 데이터 영역(data plane)에 집중. 데이터 플레인은 특정 시점에서 네트워크 트래픽이 어떻게 이동하는지 정하는 규칙들의 집합. 네트워크에는 제어 영역(control plane)이 있으며, 제어 영역은 매 시점마다 사용할 경로를 결정하는 분산 라우팅 프로토콜로 구성됨. 제어 영역 분석은 특정 시점이 아닌 앞으로 가능한 모든 시점의 제어 영역이 만들어 낸 데이터 영역의 성질을 알아 내야 함. 기존 연구는 큰 네트워크에 적용되기 어려움. 이 연구에서는 요약 실행을 제어 영역 분석에 적용. 이 연구의 핵심은 어떻게 요약할지, 왜 그 요약을 사용하는지, 어떤 성능 향상이 가능한지, 언제 요약이 건전한지 등을 고려하는 데 있음. 적절한 요약을 사용하면 정확도를 잃지 않고 점근적 성능 향상을 이룰 수 있음을 확인했으며 기존의 분석 방법보다 성능이 훨씬 뛰어남을 확인.

### Executable Formal Semantics for the POSIX Shell
POSIX 셸은 역사가 길고 널리 사용되며 매우 중요한 역할을 함에도 불구하고 잘 이해되어 있지 않음. 부분식을 계산하는 대신 문자열로 취급하고 그 안의 특수한 제어 코드를 팽창시키는 등 일반적이지 않은 의미를 포함. 이 연구에서는 처음으로 POSIX 셸의 작은 걸음 연산 의미를 정형화하고 이를 구현함. 구현체는 운영 체제 함수에 대해 매개화되어 있음. 실험을 통해 구현체가 다른 실사용되는 셸들과 비교했을 때 POSIX 표준에 가장 일치함을 확인했으며, 실사용되는 셸들의 버그를 발견.

### Mechanized Semantics and Verified Compilation for a Dataflow Synchronous Language with Reset
데이터 흐름 언어의 연산자들은 스트림에 시점별로 적용되며 상태는 단위 지연으로 표현됨. 데이터 흐름 언어는 제어 소프트웨어를 설계하는 데 핵심. 노드의 값을 초기 상태로 되돌릴 수 있도록 재설정(reset) 연산자가 지원됨. 기존 연구에서는 재설정 연산자를 고려하지 않은 채로 데이터 흐름 언어의 의미를 정의하고 컴파일러의 올바름을 증명함. 이 연구에서는 재설정 연산자가 있는 데이터 흐름 언어의 의미를 정의하고 컴파일러의 올바름을 증명. 데이터 흐름 의미와 재설정 연산자의 명령적 성질을 조화시키는 것이 핵심 문제.

### The Future is Ours: Prophecy Variables in Separation Logic
예언 변수(prophecy variable)는 보조 변수(auxiliary variable)의 일종으로, 실제 프로그램 실행의 물리적 상태에 존재하지는 않지만 앞으로의 실행에서 일어날 일에 대한 정보를 담고 있음. 예언 변수는 두 상태 기계 사이의 정제 관계를 보이기 위해 도입된 개념으로, Hoare 방식 프로그램 논리에 적용하려는 시도는 거의 없었음. 이 연구에서는 Hoare 방식 프로그램 논리에 예언 변수를 추가하고, 이것이 다양한 동시성 프로그램의 검증 문제를 해결하기에 충분하다는 것을 확인. 핵심 발상은 예언 변수를 동시성 분리 논리의 소유 가능한 자원(ownable resource)로 모델링하는 것.

### Graduality and Parametricity: Together Again for the First Time
기존 연구에서는 동적 점진적 보장과 매개성을 모두 만족하는 점진적 언어를 만들지 못함. Toro와 동료들은 시스템 F의 점진적 변형이 동적 점진적 보장과 매개성을 동시에 만족시킬 수 없음을 주장함. 이 연구에서는 처음으로 동적 점진적 보장과 매개성을 모두 만족하는 점진적 언어를 제시. Toro와 동료들이 사용한 논리적 관계가 매개성의 표준적인 개념을 제대로 표현하지 못한다는 것을 보이며, 시스템 F의 문법을 수정함으로써 동적 점진적 보장과 매개성을 모두 만족시킬 수 있음을 보임. 이 연구의 핵심은 점진적 보장과 매개성이 지켜지지 않는 원인이 타입 유도 계산(type-directed computation)에 있음을 밝히고 봉인(sealing)을 명시적으로 하도록 시스템 F의 문법을 수정한 것.

### Disentanglement in Nested-Parallel Programs
프로그래머가 병렬 반복문과 fork/join 등을 사용해 병렬성을 고수준에서 표현할 수 있는 중첩된 병렬 계산이 널리 사용됨. 메모리 효과가 있는 상황에서의 중첩된 병렬 프로그래밍은 어려움. 순수 함수형 언어는 경쟁을 피하면서도 고차 함수를 사용해 병렬 알고리즘을 간결하게 표현할 수 있게 하지만, 메모리를 많이 필요로 한다는 점으로 인해 비효율적. 이 연구에서는 한 스레드가 동시에 실행 중인 다른 스레드에 의해 할당된 메모리에 접근할 수 없다는 성질인 얽힘 풂(disentanglement) 성질을 제시하고 모든 결정된 비경쟁(determinacy-race-free) 프로그램이 이 성질을 만족함을 증명. 얽힘 풂 성질을 공략해 중첩된 병렬 프로그램의 메모리 관리를 효율적으로 할 수 있음을 보임. 핵심 발상은 메모리를 나무로 표현하며 잎은 동시에 실행 중인 스레드로 간주하는 것.

### Binders by Day, Labels by Night: Effect Instances via Lexically Scoped Handlers
대수적 효과와 처리기는 다양한 효과가 존재하는 프로그램을 모듈적으로 구현할 수 있게 함. 각 식이 수행하는 효과에 대한 정적 보장을 얻기 위해 정적 타입 및 효과 체계와 함께 사용. 각 효과를 각각의 처리기로 처리할 수 있으므로 서로 다른 여러 효과가 존재하는 프로그램을 만들기는 쉽지만, 같은 효과의 서로 다른 인스턴스를 다루는 프로그램을 작성하기는 어려움. 여러 수정 가능한 메모리 셀이나 여러 근원의 무작위 값을 다루는 프로그램이 그 예시. 이 연구에서는 각 효과의 사용이 이름에 의해 하나로 결정될 수 있는 문법적으로 영역이 결정된(lexically scoped) 효과에 기반한 해결책을 제시.

### Visualization by Example
데이터를 시각화하는 것은 여러 전문 지식을 필요로 하는 어려운 작업. 이 연구에서는 예시를 통한 시각화(visualization by example)이라는 새로운 기술을 제시. 이 기술은 프로그램 합성을 통해 데이터 시각화 작업을 자동화함. 사용자는 데이터의 일부에 대한 시각화 스케치를 데이터와 함께 제공하면, 데이터를 시각화하는 시각화 스크립트가 자동으로 만들어짐. 시각화 문제는 두 세부 문제로 나눌 수 있음. 1) 데이터 논쟁(wrangling): 모양 바꾸기, 합치기, 열 추가 등. 2) 적절한 시각화 연산을 변형된 데이텅에 적용. 사용자가 시각화 문제를 직접 두 문제로 나누는 것은 어렵기 때문에 이 연구에서는 시각화 문제를 두 합성 문제로 자동으로 나누는 방법을 제시. 표를 변형하는 프로그램을 합성하는 새로운 알고리즘도 제시.

### A Language for Probabilistically Oblivious Computation
망각 계산(oblivious computation)은 직/간접적인 정보 누설이 없는 것. ORAM(망각 RAM)은 주소와 데이터 사이의 매핑을 난독화해 많은 보안 문제를 해결하지만 성능 문제를 발생시키며, 이를 해결하기 위해 ORAM을 프로그램에서 부분적으로 해결하는 방법이 제시되었고 이를 바탕으로 ORAM에서 효율적으로 작동하는 자료 구조인 망각 자료 구조가 제시됨. ObliVM은 무작위 수를 조심히 다룸으로써 ORAM을 사용하는 프로그램을 잘 작성할 수 있게 하는 언어이나, 올바른 타입의 프로그램에 보안 문제가 없는지 확인된 바 없음. 이 연구에서는 균등하게 분포된 무작위 수를 만들고 사용하는 기능을 제공하는 λobliv를 제시하고, 이 언어의 타입 체계가 확률적 메모리 트레이스 망각을 만족함을 증명. 타입 체계는 무작위 수를 아핀하게 다룸으로써 자유롭게 복사될 수 없도록 하며, 확률 지역(probability region)을 도입해 확률적 값들을 추적.

### Interaction Trees: Representing Recursive and Impure Programs in Coq
기계로 확인된 증명은 여러 분야에서 사용되며 상호작용이나 효과가 있고 종료되지 않을 수 있는 계산을 모델링하고 논증해야 하며, 이를 위해 연산 의미가 사용됨. 연산 의미는 표현력이 높고 재귀적 논증 방식을 잘 적용할 수 있으나 구성적이지 않고 프로그램 카운터와 같은 보조 정의들을 필요로 하며 실행 가능하지 않다는 문제가 있음. 이 연구에서는 상호작용 나무(interaction tree)를 제시. 상호작용 나무는 재귀적이고 효과가 있으며 환경과 상호작용할 수 있는 계산을 모델링하기 위한 자료 구조로, Gallina의 순수성과 종료에 대한 제약에도 불구하고 효과 있고 종료되지 않는 계산을 위한 표시 의미를 제공.

### Synthesizing Replacement Classes
라이브러리를 사용하는 애플리케이션은 때때로 라이브러리의 새로운 버전이나 비슷한 기능을 제공하는 다른 라이브러리를 사용하도록 리팩토링됨. 라이브러리가 업데이트될 때 반드시 하위 호환성을 보장하지 않기 때문에, 라이브러리 교체를 수작업으로 진행하는 것은 오류를 발생시키기 쉬움. 이 연구에서는 기존 클래스 O와 O를 대체하는 클래스인 R이 주어졌을 때 R만을 사용해 O가 제공하는 메서드들을 자동으로 함성하는 기술을 제시하고 MASK라는 시스템을 제작. MASK는 두 단계로 이루어짐. 첫 단계에서는 각 클래스의 모든 메서드를 기호 실행해 얻은 기호 식들을 비교해 동치 술어를 만듦. 둘째 단계에서는 제안된 술어를 바탕으로 R의 메서드 호출을 나열하는 방법으로 O의 메서드와 동일한 일을 하는 메서드를 합성.

### Kind Inference for Datatypes
Haskell에는 고차 카인드와 카인드 다형성이 존재. 각 데이터 타입 정의가 타입 검사를 통과할 수 있는지와 각 데이터 타입이 어떤 카인드를 가지는지 알아내는 문제는 중요하지만 잘 탐구되지 않았음. 이 연구에서는 기존의 타입 추론 연구를 바탕으로 Haskell의 카인드 추론 문제를 탐구. Haskell98의 카인드 추론 알고리즘을 제시하며 이 알고리즘을 완전하게 만들기 위한 타입 체계의 변종을 제안. 최신 Haskell의 카인드 추론 알고리즘을 제시하며 건전성을 증명하고 완전하지 않은 이유를 설명.

### Synthesis of Coordination Programs from Linear Temporal Specifications
IoT 등에서 조정자(coordinator)는 여러 센서와 기기와 통신하여 행동을 결정하고 제어. 이 문제는 통신 순차 프로세스(CSP; communicating sequential process) 프레임워크를 통해 설명할 수 있지만, 기존의 CSP 합성과는 여러 차이가 있음. 비동기적이며, 공유 메모리 대신 메시지 전달을 통해 통신. 또한, 현재 상태에 대한 부분적인 정보만 가진 상태에서도 조정자가 올바르게 동작해야 함. 이 연구에서는 선형 시간 논리(LTL; linear temporal logic)로 작성된 명세를 처리해 CSP 합성을 하는 알고리즘을 제시.

### A Probabilistic Separation Logic
확률적 프로그램을 검증하는 데 중요한 성질 중 하나는 독립. 독립이 그 자체로 목표가 되는 경우는 드물지만 지역 논증을 가능하게 하기에 유용. 이 연구에서는 BI(bunched implications)의 새로운 해석을 제시해 분리 곱을 두 독립적인 분포로 나누어질 수 있는 분포를 표현하게 함. 이를 바탕으로 간단한 확률적 프로그래밍 언어를 위한 프로그램 논리를 제시하고, 분리 논리의 격자 규칙에 해당하는 규칙을 제시. 제안한 프로그램 논리를 통해 알려진 확률적 프로그램의 보안 관련 성질들을 검증함.

### Augmented Example-Based Synthesis using Relational Perturbation Properties
예시 기반 합성은 프로그램의 여러 입력에 따른 출력을 사용자가 제공하면 자동으로 주어진 예시를 만족하는 프로그램을 합성. 비전문가도 쉽게 사용할 수 있다는 장점이 있지만, 예시를 만족하는 프로그램이 여럿이기 때문에 의도하지 않은 결과를 얻을 수 있다는 단점이 있음. 기존에는 도메인 특화 지식을 바탕으로 한 문법 편향이나 사용자의 피드백을 반복적으로 맏아 해결. 이 연구에서는 관계적 변화 성질(relational perturbation property)에 기반한 해결책을 제시. 관계적 변화 성질이란 입력이 바뀌었을 때 출력이 어떻게 바뀌는지에 대한 것. 예를 들면 순열 불변 성질. 요구되는 관계적 변화 성질에 따라 주어진 예시에 더해 추가적인 예시를 자동으로 만들고 합성을 진행. 관계적 변화 성질을 정하는 세 가지 방법 제시(사용자가 직접 선택, 사용자와의 상호작용을 통해 알아냄, 주어진 예시만 가지고 추론).

### Semantics of Higher-Order Probabilistic Programs with Conditioning
이 연구에서는 고차 확률적 프로그램의 표시 의미를 Banach 공간 사이의 선형 연산자로 나타냄. 이 의미는 직관주의적 선형 논리의 모델. Gibbs 샘플링 알고리즘을 검증하는 데 의미를 사용함.

### The Fire Triangle: How to Mix Substitution, Dependent Elimination, and Effects
이 연구에서는 CBPV를 의존적 타입을 포함하도록 확장한 ∂CBPV을 제안. 효과가 있을 때 의존적 제거(dependent elimination)는 이름에 의한 호출로 제한되어야 하고, 치환은 값에 의한 호출로 제한되어야 하는 이유를 설명.

### SyTeCi: Automating Contextual Equivalence for Higher-Order Programs with References
두 프로그램이 동치임을 보이는 것은 중요한 문제이나 사적 메모리 셀을 조작하는 고차 프로그램의 문맥 동치를 판단하는 것은 기존 연구에서 잘 다루어지지 않음. 이 연구에서는 두 프로그램의 문맥 동치 문제를 구조화된 메모리 전이 기계(STMT; structured-memory transition machine)의 실패한 구성으로의 도달 불가능성 문제로 환원하는 SyTeCi 프레임워크를 제안. 만약 기계에서 실패한 구성으로 도달하는 경로가 존재한다면, 두 프로그램을 구분할 수 있는 문맥이 존재한다는 것을 뜻함. 이 방법은 재귀가 없는 프로그램에 대해 완전. 재귀가 있는 프로그램의 경우 두 프로그램이 너무 다르면 STMT를 만들 수 없음.

### Detecting Floating-Point Errors via Atomic Conditions
부동 소수점의 제한된 정확도로 인해 부동 소수점 연산에 오류 발생 가능. 부동 소수점 프로그램이 이에 대응되는 수학적 오라클과 큰 오차를 내는지 확인하는 것이 중요. 지금까지의 방식은 더 높은 정확도의 프로그램을 오라클로 사용하고 원래 프로그램을 블랙 박스로 취급. 더 높은 정확도의 프로그램은 느리고 원래 프로그램에 대응되는 높은 정확도의 프로그램을 올바르게 만들기 어렵다는 것이 기존 방식의 단점. 이 연구에서는 조건 수(condition number)에 기반한 새로운 방식 제시. 조건 수는 입력이 작게 바뀌었을 때 출력이 얼마나 바뀌는지 측정한 것. +, - ,sin, log와 같은 연산의 조건 수에 집중하며, 이를 원자 조건(atomic condition)이라 부름.

### Guarded Kleene Algebra with Tests: Verification of Uninterpreted Programs in Nearly Linear Time
KAT(Klenne Algebra with Tests)은 다양한 계산을 모델링하기 위해 사용됨. GKAT(Guarded Kleene Algebra with Tests)은 KAT에서 합집합과 무제한 반복을 보호된(guarded) 형태인 조건과 반복으로 바꾼 것. 이 연구에서는 GKAT을 탐구. GKAT은 KAT보다 제한적이지만 많은 실용적인 검증 문제를 푸는 데 사용할 수 있음. KAT에서 프로그램의 동치를 판단하는 것이 PSPACE인 것에 비해, GKAT에서는 거의 선형 시간임을 보임. 또한, 확률적 언어에 GKAT에 더 적합한 기반인 것을 주장.

### Provenance-Guided Synthesis of Datalog Programs
이 연구에서는 Datalog 프로그램을 기원 유도(provenance-guided) 방식으로 합성하는 방법을 제시. 매 반복마다 SAT 해결기는 Datalog 프로그램을 제안하고, 이 제안은 두 가지(요구되지 않는 튜플을 출력함, 요구되는 튜플을 출력하지 못함) 중 하나의 이유로 실패할 수 있음. 첫 번째 경우를 인코딩하는 제약 조건은 “왜" 기원의 고전적 모델로부터 얻을 수 있음. 두 번째 경우는 새롭게 제시한 두 가지 방법(델타 디버깅과 쌍대 기원)을 사용.

### Full Abstraction for the Quantum Lambda-Calculus
기존 연구는 양자 람다 대수의 정적 표시 의미(양자 관계 모델)와 동적 표시 의미(양자 게임 의미)를 제시했으나, 완전 요약(fully abstract)이라고 알려진 모델은 없음. 두 항의 의미가 같다는 것과 두 항이 문법적으로 구분될 수 없다는 것이 동치일 때 의미가 완전 요약이라고 함. 이 연구에서는 처음으로 양자 람다 대수의 게임 모델이 완전 요약임을 증명.

### Backpropagation in the Simply Typed Lambda-Calculus with Linear Negation
자동 미분은 자코비안을 연쇄 법칙에 따라 계산하는 방법. 입력에서 출력으로 도함수를 전달하는 정방향 방법과 그 반대 방향인 역방향 방법이 있음. 심층 학습에서는 역방향이 더 효율적이며, 이에 특화된 역전파 알고리즘을 사용. 미분 가능한 프로그래밍은 조건, 재귀 호출, 고차 함수 등을 포함하는 프로그램을 자동으로 미분하는 것. 이 연구에서는 역전파 알고리즘을 계산 그래프에서 일반적인 단순 타입 람다 대수 항으로 확장한 구성적인 프로그램 변형을 제시.

### Does Blame Shifting Work?
책임(blame)은 고차 계약이 있는 프로그램의 버그를 찾는 데 도움된다고 믿어져 왔으나, 이에 대한 체계적인 근거는 없음. 이 연구에서는 책임의 유용성을 확인. 다음의 두 질문에 대해 실험을 통한 답을 찾음. 프로그래머가 책임에 신경 쓰고 책임 있는 부품에 집중함으로써 잘못된 부품을 찾을 수 있는가? 책임의 지도를 통해 버그의 위치에 점점 더 가까이 다가갈 수 있는가? 책임 있는 부품에 버그가 없다고 생각한다면, 프로그래머는 부품 사이 계약의 정확도를 올림으로써 책임 이동(blame shift)을 시도할 것이라 기대 가능. 앞의 두 질문은 책임 이동을 통해 잘못된 부품을 찾을 수 도달 가능한지, 책임 이동이 언제나 책임을 버그에 더 가깝게 만드는지로 바꿀 수 있음.

### Decidable Subtyping for Path Dependent Types
경로 의존 타입을 제공하는 DOT의 서브타입 검사는 결정불가능. Java 제네릭스는 재귀적 상속의 존재로 인해 서브타입 검사가 결정불가능하며, 기존 연구에서는 서브타입 검사가 결정가능한 Java의 부분 집합을 제시. 핵심 발상은 순환적 서브타입 정의가 가능한 모양(shape)과 불가능한 물질(material)로 타입을 구분하는 것. 이 연구에서는 DOT에 물질 모양 구분을 적용해 결정가능한 변종 두 개를 제시. 물질 모양 구분만으로는 결정가능성을 보장하기에 부족했으며, 두 개의 추가적인 제약을 제안.

### Label-Dependent Session Types
세션 타입은 통신 프로토콜의 자세한 정적 제어가 가능하게 함. 세션 타입은 메시지의 나열을 나타냄. 근본적으로 같은 연산에 대한 여러 문법적 형태가 만들어짐. 이를 극복하고자 원시 통신 연산의 수를 줄이려는 시도가 있었음. 한 타입을 다른 타입으로 인코딩할 수 있지만, 고수준 동작은 같아도 실제로 교환되는 메시지는 다르다는 한계가 있었음. 이 연구에서는 라벨 의존 세션 타입을 제시. 라벨 의존은 굉장히 제한적인 형태의 의존 타입으로, 값이 유한 집합에서 선택된 라벨에 의존하는 것을 허용. 전송과 수신이라는 한 쌍의 통신 연산만 필요하다는 장점이 있음.

### Pointer Life Cycle Types for Lock-Free Data Structures with Memory Reclamation
동시성 프로그램에서 락 없는(lock-free) 자료 구조는 널리 사용되지만 그 올바름을 증명하기 어려움. 메모리 수집기의 존재를 가정하고 자동으로 올바름을 검증하는 기술이 존재하나, C/C++에서는 프로그래머가 메모리를 직접 관리하며, 동시성 프로그램에서는 SMR(safe memory reclamation) 알고리즘을 사용해야 함. SMR 알고리즘은 검증을 어렵게 만들지만, Meyer와 Wolff는 자료 구조가 메모리 안전하다면 SMR 알고리즘이 아닌 메모리 수집기에 의존하는 것처럼 검증될 수 있음을 제시. 메모리 안전성을 자동으로 확인하는 것이 어려움. 이 연구에서는 락 없는 자료 구조의 메모리 안전성을 보장하기 위한 타입 체계를 제시.
