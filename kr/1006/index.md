### Fixpoints for the masses: programming with first-class Datalog constraints
Datalog는 강력한 논리 프로그래밍 언어지만 사용에 두 가지 어려움이 있음 1) 범용 프로그래밍 언어와의 통합이 잘 되지 않아 제약 조건을 만들어 파일에 저장하고 Datalog 엔진을 실행한 뒤 결과를 받아야 함. 2) 모듈적인 Datalog 프로그램을 만들 메커니즘이 없음. 이 연구에서는 Datalog 프로그램이 일급 값으로 취급되어 만들어지고, 결합되고, 해결될 수 있는 함수형 언어를 람다 대수를 확장해 제시. Hindley-Milner 타입 체계와 행 다형성(row polymorphism)을 통한 술어 심볼 추적을 바탕으로 타입 추론이 가능한 타입 체계를 제시하고 건전성을 증명. Flix 언어에 실제로 구현하고 사용 사례를 제시.

### Effects as capabilities: effect handlers and lightweight effect polymorphism
효과에 대한 전통적인 시각은 함수의 부작용이나 추가적인 출력으로, 효과 있는 식은 계산 문맥을 수정. 이 연구에서는 효과에 대한 새로운 시각을 제시. 이 시각에서는 효과가 호출자나 함수에 주어진 입력에 대한 요구 사항을 나타내며, 효과 있는 식은 계산 문맥에 의존. 이로써 효과 타입은 계산이 가지는 부작용을 표현하는 것이 아니라, 계산이 문매게 요구하는 능력(capability)를 표현하는 것이라 해석할 수 있음. 이 연구에서는 새로우 시각을 바탕으로 문법적 범위를 가진 효과를 제공하는 언어인 Effekt를 제시.

### A systematic approach to deriving incremental type checkers
IDE 등에서 타입 검사기를 증분(incremental)하게 만드는 것은 중요한 일이나, 대부분은 특정 타입 체계에 특화된 타입 검사기를 만들며, 임의의 타입 체계에 대해 증분 타입 검사기를 만드는 일반적 방법은 없음. 이 연구에서는 타입 체계 명세로부터 증분 타입 검사기를 만드는 체계적인 방법을 제시. 핵심 발상은 타입 체계의 추론 규칙들을 Datalog로 옮기는 것. Datalog는 유한한 관계만 다루는 것과 달리, 타입 체게는 귀납적으로 정의된 무한한 관계를 다루므로 옮기는 것이 어려움. 타입 체계의 성질을 활용하는 여러 단계의 변형을 통해, 타입 체계를 설명하는 도메인 특화 언어로부터 Datalog 프로그램이 만들어질 수 있게 함. 오버로딩, 지역 타입 추론, 보편 타입 등 여러 타입 체계에 적용해 잘 작동하는 것을 확인.

### Proving highly-concurrent traversals correct
동시성 알고리즘에 요구되는 성질은 선형화 가능성(linearizability)이며 증명하기 어려우나, 최근 연구는 순차적 논증을 통한 증명 방법을 제시. 그러나 이를 사용하기 위해 만족해야 하는 조건이 있으며, 조건이 복잡하거나 일부 자료 구조에 의해 만족되지 않는 문제가 있음. 이 연구에서는 더 간단하고 널리 적용 가능한 조건에 기반하는 증명 기술을 제안하며, 탐색(traversal) 올바름을 증명하는 것을 목표로 함. 탐색 올바름을 형식적으로 정의했으며 이를 증명하기 위한 조건인 과거(forpassed) 조건을 제시. 과거 조건은 쓰기가 메모리에 대한 도달 가능성을 줄이지 않는다는 것을 요구하여, 쓰기와 탐색을 위한 읽기 사이의 간섭을 고려할 필요를 없앰. 이 프레임워크를 사용해 몇몇 동시성 자료 구조의 올바름을 증명함.

### Certified and efficient instruction scheduling: application to interlocked VLIW processors
CompCert는 올바름이 검증된 컴파일러로 여러 최적화를 제공하지만 명령어의 순서를 바꾸는 최적화는 하지 않음. 여러 비순차적 실행 프로세서에서는 컴파일러가 명령어 스케줄링을 할 필요가 없지만, 순차적 실행 프로세서에서는 컴파일러의 명령어 스케줄링을 통해 성능을 향상시킬 수 있음. VLIW 프로세서는 어셈블리 코드가 병렬적으로 실행 가능한 명령어들을 명시할 것을 요구. 이 연구에서는 CompCert를 확장해 순차적 실행 VLIW 프로세서를 목표로 하고, 명령어 스케줄링을 지원하며, 올바름이 검증된 컴파일러를 제시. 검증된 스케줄링은 이전에 제안된 바 있으나, Asm 대신 그 이전 수준인 Mach에서 스케줄링을 하고, 기본 블록 크기에 대해 지수적 복잡도를 요구하며, 종료되지 않는 프로그램은 고려하지 않은 문제가 있었음. 이 연구에서는 해당 문제를 모두 해결.

### Enabling accuracy-aware Quantum compilers using symbolic resource estimation
양자 프로그램에는 여러 이유로 인해 근사 오차가 발생. 기존에는 프로그래머가 발생한 오차를 모두 추적하고 프로그램의 전체 오차를 목표치 이하로 만들기 위해 정확도 매개변수를 직접 조절해야 했으며, 이는 복잡하고 실수하기 쉬움. 이 연구에서는 기존 양자 프로그래밍 언어에 오차 추적 기능을 추가해, 프로그래머가 각 서브루틴의 오차만 고려하면 컴파일러가 전체 오차를 알아내도록 함. 컴파일러는 사용자가 정한 오차 허용치 안에 드는 오차를 내면서 필요한 자원을 최소화하는 프로그램을 자동으로 만듦. 필요 자원을 근사하기 위해 새로운 기호적 방법을 도입.

### Semiring optimizations: dynamic elision of expressions with identity and absorbing elements
반환(semiring)에는 a+z=a와 b×z=z를 만족하는 원소 z가 존재. 이 사실을 바탕으로 a:=a+e, a:=b×e, a:=a+b×e 등의 식을 e가 z일 때는 nop이나 a:=z로 바꿈으로써 ld 명령의 수를 줄이는 최적화를 할 수 있음. 이를 반환 최적화라 부름. ld가 줄어드는 대신 조건 가지가 추가되기 때문에 성능 향상이 이루어진다는 보장이 없음. 이 연구에서는 반환 최적화를 성능 안전(performance safe)한 방식, 즉 프로그램이 충분히 오래 실행될 때 적어도 성능이 나빠지지 않는 방식으로 구현하는 방법을 제시. 성능 안전성을 위한 핵심 발상은 최적화된 프로그램이 실행되는 동안 진행되는 온라인 프로파일링. 실험을 통해 35 개의 프로그램에서 평균 1.19 배의 성능 향상을 확인.

### Can advanced type systems be usable? An empirical study of ownership, assets, and typestate in Obsidian
Obsidian은 스마트 계약의 취약점을 해결하기 위해 제시된 새로운 프로그래밍 언어. Obsidian의 타입 체계는 선형 타입, 소유권, 타입 상태, 자산(asset) 등을 포함. 이 연구에서는 개발자들이 이런 복잡한 기능을 제공하는 타입 체계를 잘 사용할 수 있는지 알기 위해 Obsidian과 Solidity를 사용자 연구(user study)를 통해 정량적으로 비교. 90 분 정도의 교육 시간 후 Obsidian 참가자와 Solidity 참가자들은 동일한 임무를 수행. 교육 시간을 포함하는 전통적인 연구 방식이 새로운 프로그래밍 언어를 평가하는 데 효과적임을 확인. 짧은 시간 안에도 소유권 체계를 배우고 효과적으로 사용할 수 있음을 확인. 자산을 잃는 버그를 탐지하거나 방지하는 기술 없이는 프로그래머들이 실수로 그런 버그를 만들 수 있음을 확인.

### Assertion-based optimization of Quantum programs
양자 프로그램의 많은 최적화는 수작업에 의해 이루어지며 이는 컴파일러 최적화가 더 발전할 수 있음을 뜻함. 이런 최적화는 대개 둘 이상의 존재하는 서브루틴이 조합될 때 가능하며, 최적화를 위해서 컴파일러는 주어진 서브루틴이 어떤 상황에서 호출되는지 알아야 함. 컴파일러는 해당 정보를 표명(assertion)으로부터 알아낼 수 있음. 이 연구에서는 양자 컴퓨터의 부분 체계들이 어떻게 얽히는지와 어떤 상황에서 프로그램이 최적화될 수 있는지 표현하는 형식을 제시하고 이를 바탕으로 양자 프로그램을 최적화.

### Multiparty motion coordination: from choreographies to robotics programs
로봇은 안전성이 중요하지만 동작의 올바름을 논증하기는 어려움. 이 연구에서는 동시성 로봇 시스템을 위한 프로그래밍 모델과 정적으로 프로그램의 안전성을 검사하기 위한 타입 체계를 제시. 타입 체계는 안무(choreography)에 기반하며, 다자간(multiparty) 세션 타입에 동적 동작 원시(dynamic motion primitive)를 추가. 기존 연구는 전역 동기화에 의존한다는 단점이 있으며 이를 극복. 올바른 타입의 프로그램은 통신 안전성(메시지를 받거나 보낼 준비가 됨), 동작 안전성(올바르게 동작 원시를 실행), 충돌 안전성(궤적이 분리되어 있음)을 보장.

### Automated policy synthesis for system call sandboxing
시스템 호출 샌드박스는 사용자가 제공한 샌드박스 정책을 따르는 패턴의 시스템 호출만 프로그램이 할 수 있도록 강제함으로써 프로그램의 보안 취약점이 공략당한 경우에 피해가 커지는 것을 막음. 시스템 호출 샌드박스는 현재 널리 사용되지 않는데, 개발자가 정책을 작성하기 어렵기 때문. 프로그램의 모든 시스템 호출을 찾아야 하고, 프로그램이 수정되면 정책도 수정되어야 하며, 서로 다른 운영 체제는 각각 다른 정책 언어를 제공하고, 정책이 잘못 작성될 시 프로그램의 올바른 실행조차 강제 중단시킬 수 있음. 이 연구에서는 C/C++ 프로그램을 위해 샌드박스 정책을 자동으로 합성하는 기술을 제시. 첫 단계에서는 요약 실행을 통해 시스템 호출 사용 패턴을 근사하고, 둘째 단계에서는 근사된 사용 패턴을 가장 정확하게 표현하는 정책을 찾음.

### How do programmers use unsafe rust?
Rust는 타입 체계가 허용하지 않는 코드를 프로그래머가 짤 수 있도록 안전하지 않은(unsafe) Rust를 제공. 안전하지 않은 코드를 사용할 때의 원칙은 (1) 드물게 사용하고 (2) 수작업으로 올바름을 확인할 수 있도록 쉽고 스스로 모든 정보를 포함해야 하고 (3) 안전한 요약 속에 감추어져 있어야 한다는 것. 이 논문에서는 이 세 가지 원칙을 Rust 가정이라고 부름. 이 연구에서는 안전하지 않은 코드가 현실에서 어떻게 사용되는지 실증적 연구를 진행. 연구 결과는 Rust 가정을 부분적으로 지지. 대부분의 안전하지 않은 코드는 간단하고 잘 감추어져 있으나, 상당히 많이 사용됨(특히 다른 언어와의 상호 연산을 위해).

### Learning semantic program embeddings with graph interval neural network
기계 학습 모델이 소스 코드의 표현을 학습할 수 있도록 최근 사용된 방식은 GNN(graph neural network)를 사용하는 것. GNN은 프로그램을 그래프로 나타낸 것으로부터 학습. GNN은 일반적인 그래프를 학습하도록 설계되었기 때문에, 프로그램을 표현한 그래프의 특징을 잘 활용하지 못하고 비용이 크다는 문제가 있어 큰 그래프로 표현되는 프로그램을 처리할 때 정확도를 잃어 버림. 이 연구에서는 GNN을 개량해 GINN(graph neural network)를 제시. GNN과 달리 GINN은 반복문에서 주로 나타나는 형태인 간격(interval)에 집중해 프로그램의 특성을 찾아 냄. GINN을 변수 오용 예측과 메서드 이름 예측에 사용해 기존 GNN 기반 방식보다 더 잘 작동함을 확인.

### Mossad: defeating software plagiarism detection
많은 과제 답안이 온라인에 존재하고 전산학 수강생이 증가했기 때문에 여러 학생에게 과제 표절은 매력적인 선택이며, 많은 강사들이 과제 표절을 탐지하기 위해 Moss와 같은 표절 탐지기를 사용. 여기에는 표절 탐지기를 통과할 정도로 프로그램을 수정할 학생은 스스로 과제를 할 능력도 있다는 가정이 있음. 이 연구에서는 Moss 등의 표절 탐지기가 탐지하지 못하도록 주어진 프로그램을 변형하는 도구인 MOSSAD를 제시. Moss의 탐지 알고리즘에서 취약점을 찾고 이를 공략함.

### Handling bidirectional control flow
복잡한 제어 흐름을 표현할 수 있도록 여러 언어가 발생기(generator)나 async-await과 같은 제어 흐름 이동 기능을 제공. 대수적 효과는 프로그래머가 자신만의 제어 흐름을 직접 정의할 수 있게 하여 예외, 발생기, async-await을 모두 표현하며, 효과를 모나드로 표현하는 것보다 더 자연스럽게 조합됨. 어떤 복잡한 제어 흐름은 양방향 대수적 효과를 필요로 함. 동시에, 모든 효과가 처리된다는 것과 어떤 효과도 의도치 않게 처리된다는 일이 없다는 보장이 있어야 함. 이 연구에서는 양방향 제어 효과를 제공하면서도 다른 바람직한 성질을 만족하는 언어를 제시.

### Scaling exact inference for discrete probabilistic programs
확률적 언어의 주된 과제는 확률 추론(프로그램에 의해 정의된 확률 분포로부터 특정 사건이 일어날 확률을 계산하는 것). 많은 도메인에서 이산 확률 분포에 대한 확률 추론이 필요. 기존의 확률적 언어는 주로 연속 분포에 초점을 두며, 프로그램의 구조에 대해 너무 강한 가정을 하거나 이산 확률 분포의 특징을 잘 공략하지 못함. 이 연구에서는 이산 확률적 프로그램을 나타내는 도메인 특화 언어인 Dice를 제시하고, 큰 프로그램에서도 잘 작동하는 빠르고 효율적인 이산 확률 프로그램 추론 엔진을 설계.

### Formulog: Datalog for SMT-based static analysis
SMT 해결은 많은 정적 분석의 핵심 부품. Datalog는 논리 프로그래밍 언어로, 다양한 정적 분석을 저수준 구현에 신경 쓸 필요 없이 명세 수준에서 분석기를 만들 수 있게 하며, 최적화가 잘 되어 있음. SMT 해결의 중요성과 Datalog의 장점에도 불구하고 Datalog의 장점을 SMT 기반 분석으로 확장하는 방법에 대한 연구는 잘 되어 있지 않음. 이 연구에서는 Datalog에 SMT 해결기와 ML의 일차 함수를 추가해 만든 Formulog를 제시. Formulog 프로그램은 ML 방식의 함수 정의와 Datalog 방식의 규칙들로 이루어지며 서로가 서로를 참조할 수 있으며 SMT 연산을 사용할 수 있음. SMT 공식은 ML 항으로 표현됨. Formulog 프로그램은 Datalog 알고리즘에 의해 효과적으로 최적화 및 계산됨.

### Precise inference of expressive units of measurement types
단위가 올바르도록 계산을 구현하는 것은 어려 분야에서 중요한 일이며, 차원이나 단위가 맞지 않는 계산은 큰 문제를 일으킬 수 있음. 효율성을 위해 단위나 차원은 새로운 타입으로 정의되기보다는 그냥 원시 타입을 사용하기에 단위가 올바르게 사용되는지 정적으로 거의 보장할 수 없음. 이 연구에서는 단위의 올바른 사용을 강제하는 타입 체계인 PUnits을 제안. PUnits은 Java의 옵션 타입 체계로 구현되었으나 발상 자체는 Java에 국한되지 않음. PUnits은 타입 추론을 통해 가장 정확한 단위 표시를 찾아 줄 수 있음. PUnits의 건전성은 Coq으로 증명됨.

### WATCHER: in-situ failure diagnosis
배포 단계의 소프트웨어에도 여러 버그가 있으며, 사용자는 대개 해당 버그를 디버깅할 수 있는 능력이나 의지가 없고, 개발자는 배포 환경에 접근할 수 없기 때문에 버그를 진단하는 능력이 제한받음. 최근 연구는 메모리 덤프나 실행 기록을 기반으로 크래시 이후에 오프라인 분석을 할 것을 제안하지만, 이 방법에는 비밀 정보 누설, 소요 시간, 오프라인 분석 시 서드 파티 라이브러리의 부재, 환경에 의존하는 실패의 존재와 같은 여러 단점이 있음. 이 연구에서는 제자리(in-situ) 진단을 제안하고 이를 수행하는 WATCHER를 구현. WATCHER는 배포 환경에서 크래시가 발생하면 즉시 진단을 수행하며, 기록 후 재현(record-and-replay), 이진 분석, 동적 분석, 하드웨어 지원 등을 활용.

### A model for detecting faults in build specifications
병렬성과 증대성은 현대 빌드 시스템의 중요한 기능으로, 병렬성은 서로 독립적인 빌드 연산을 여러 CPU 코어에서 동시에 진행해 빌드 시간을 줄이고, 증대성은 코드 생긴 변화에 영향을 받는 빌드 연산만 실행하여 시간과 자원을 절약. 병렬 및 증대 빌드가 잘못되지 않으려면 개발자가 빌드 스크립트에 모든 의존 관계를 올바르게 명시해야 하며, 이는 어렵고 실수하기 쉬움. 잘못된 빌드 정의를 탐지하는 기존 연구는 Make에만 사용할 수 있고 결함 위치 찾기(fault localization)가 매우 오래 걸린다는 단점이 있음. 이 연구에서는 병렬 및 증대 빌드의 결함 탐지를 위한 효과적이고 효율적인 동적 방법을 제시. 모니터링을 통해 각 빌드 과제가 어떤 파일을 읽고 쓰는지 모델링한 후 빌드 실행의 올바름을 검증. Make와 Gradle에 적용해 보았으며, 다른 빌드 시스템에도 동일하게 적용될 수 있음.

### Guided linking: dynamic linking without the costs
동적 링킹은 널리 사용됨. 디스크와 메모리 사용량을 줄일 수 있고, 라이브러리 업데이트 시 재컴파일이 필요하지 않으며, 필요할 때만 모듈을 불러올 수 있다는 장점이 있음. 단점은 컴파일러 최적화를 막는다는 것. 컴파일러는 하나의 프로그램이나 라이브러리만 최적화하며, 링커의 동작을 예상할 수 없기 때문에 보수적으로 컴파일할 수밖에 없음. 이 연구에서는 유도 링킹(guided linkind)을 제안. 개발자는 컴파일러가 최적화할 수 있도록, 최적화 집합이라 부르는 여러 동적 프로그램/라이브러리를 제공하고 링커의 동작에 대한 제약 조건을 명시. 이를 통해 성능 향상과 코드 사이즈 감소를 이룰 수 있으며 새로운 방식의 최적화(여러 패키지에 있는 중복된 함수를 하나로 합치기 등)를 가능하게 함.

### Satune: synthesizing efficient SAT encoders
많은 분석은 제약 조건 해결에 의존. SAT 해결기의 성능은 제약 조건이 인코딩된 방식에 따라 크게 달라짐. 1000 배 가량 차이가 나는 경우도 있음. 좋은 인코딩을 찾는 것은 어려움. SAT 식의 크기에 따라 효율적인 인코딩 전략이 다르며, 도메인에 따라 인코딩 전략의 효율성이 다름. 지금까지의 연구는 SAT 해결기의 효율성을 높이는 데 집중. 이 연구에서는 고성능 도메인 특화 SAT 인코더를 합성하는 프레임워크인 SATUNE을 제시. 개발자는 도메인 문제를 SATUNE이 제공하는 도메인 특화 언어를 통해 표현할 수 있음. 반복을 통해 인코딩의 효율성을 개선하며, 분석을 통해 더 효율적인 인코딩을 만듦.

### Exposing cache timing side-channel leaks through out-of-order symbolic execution
캐시 시간 부채널 공격은 캐시와 메모리에 각각 접근하는 데 걸리는 물리적 시간 차이를 이용해 비밀 데이터를 알아냄. 프로그램의 캐시 동작을 분석해 공격을 방지할 수 있음. 현대 프로세서에서는 비순차적 실행이 널리 사용되며, 비순차적 실행은 결과에는 영향을 주지 않아도 캐시 상태에는 큰 영향을 줌. 기존 연구는 비순차적 실행하의 캐시 시간 공격을 막는 데 적용되기 어려움. 비순차적 실행을 고려하는 것은 (1) 비순차적 실행을 정확하게 표현하기 어려움 (2) 하드웨어/소프트웨어의 제한을 모델에 강제하기 어려움 (3) 비순차적 실행의 넓은 탐색 공간에서 해로운 실행을 체계적으로 찾기 어려움 등의 이유로 어려움. 이 연구에서는 비순차적 실행을 두 사건의 순서 바꾸기로 모델링하고 하드웨어/소프트웨어 제한을 기호 실행기에 강제할 수 있는 규칙으로 요약하는 등의 일을 통해 비순차적 실행하의 캐시 시간 공격 가능성을 탐지하는 기호 실행 기반 프레임워크를 제시.

### Statically verified refinements for multiparty protocols
MPST(다자간 세션 타입)은 프로세스 시스템이 주어진 프로토콜을 올바르게 구현했는지 정적으로 검증할 수 있게 하는 타입 기반 방법으로, 잘못된 메시지나 교착 상태가 없음 등을 보장할 수 있음. MPST와 현실의 표현력 높은 언어에는 큰 차이가 있기 때문에 상호작용의 다양한 제약 조건을 표현할 수 있도록 더 발전된 타입 체계가 필요. 이 연구에서는 MPST에 정제 타입을 추가한 RMPST를 제시하고, 콜백 기반 프로그래밍이라는 안전한 세션 프로그래밍을 위한 실용적 기법을 제안.

### Featherweight go
이 연구에서는 Go의 작은 모델인 Featherweight Go(FG)를 제시하고 여기에 제네릭스를 추가해 FGG를 만들었으며, FGG를 단형화(monomorphisation)를 통해 FG로 번역하는 방법을 제시. Go의 서브타입은 이름이 아닌 구조에 따른 서브타입이며, Java 제네릭스가 타입 소거를 사용하는 것과 달리 Go 제네릭스는 단형화를 사용. FG와 FGG의 타입 건전성을 증명했으며 FGG에서 FG로의 번역이 타입을 보존하고 이중 시뮬레이션임을 증명. Go가 어떻게 표현 문제(The Expression Problem)을 해결하는지 설명.

### Projection-based runtime assertions for testing and debugging Quantum programs
양자 프로그램은 다양한 곳에 적용될 수 있지만 올바르게 구현하기 어려움. 이 연구에서는 양자 프로그램의 실행 시간 테스팅과 디버깅을 위해 표명에 집중. 기존의 연구에서는 (1) 고전적 논리 언어로 작성된 서술이 양자 상태의 단순한 경우만 표명할 수 있고 (2) 일반적인 양자 상태는 복사될 수 없기 때문에 표명을 확인하기 위해 계산을 반복해야 하므로 비효율적이며 (3) 비결정적인 양자 프로그램의 특성에 대한 이론적 바탕이 부족. 이 연구에서는 양자 프로그램을 위한 사영 기반 표명을 제시. 이를 통해 표명의 표현력을 키우고 양자 컴퓨터에서 효율적으로 검사 가능하게 함. 이 기법이 통계적으로 효과적임을 증명.

### Persistent Owicki-Gries reasoning: a program logic for reasoning about persistent programs on Intel-x86
NVM(비휘발성 메모리)에 대한 여러 연구가 진행되어 영구성 의미가 정의되고 NVM을 위한 알고리즘이 제시되었으나, 이를 검증하는 기술에 대한 연구는 부족. 기존 연구에서는 저수준 증명을 제시하고, 간단하게 만들기 위한 가정을 하며, 프로그램 문법 대신 트레이스 수준에서 검증한다는 한계가 있음. 영구 자료 구조를 올바르게 만들려면 캐시를 플러시하기 위한 저수준 명령을 올바른 위치에 넣어야 하며 이는 오류를 범하기 쉬운 일이므로 올바름을 검증하는 것이 중요. 이 연구에서는 NVM에서 실행되는 다중 스레드 프로그램의 정형 검증을 위한 POG(영구 OG)를 OG(Owicki-Gries) 증명 체계를 바탕으로 제시.

### Igloo: soundly linking compositional refinement and separation logic for distributed system verification
소프트웨어 시스템의 완전한 검증은 요약 명세를 실행 가능한 코드와 형식적으로 연결하는 것으로, 둘 사이에 정제 관계를 세우는 것을 통해 이루어짐. 검증 기술은 다음 네 가지 조건을 만족해야 함. (1) 끝부터 끝까지: 시스템 전체에 대한 전역 성질을 검증할 수 있음. (2) 다재다능: 넓은 범위의 시스템에 적용 가능. (3) 표현력: 표현력 높은 언어와 논리를 지원. (4) 도구와의 상호동작: 자동화, 전문가 지식 등을 활용 가능한 일반적 도구가 존재. 기존 연구에서는 이 네 가지를 모두 만족하는 검증 기술을 제시하지 못함. 이 연구에서는 분산 시스템에 초점을 두고 이 넷을 모두 만족하는, 이벤트 기반 시스템 모델과 하향식 구성적 정제와 분리 논리를 통한 상향식 검증을 결합한 새로운 방법을 제시.

### DiffStream: differential output testing for stream processing programs
실시간 데이터 처리가 널리 사용되고 있으며 분산 환경에서 이루어짐. 분산 프로그램의 올바름을 확인하는 것은 중요한 문제. 스트림을 처리하는 프로그램을 테스트하는 기술은 잘 연구되지 않음. 이 연구에서는 스트림을 처리하는 프로그램의 차이 테스팅(differential testing)에 집중. 병행성으로 인해 출력이 비순차적이므로 스트림의 동치 조건이 완화되어야 하면서도 어떤 출력 사이에는 순서가 존재한다는 것과 입력 데이터를 모두 메모리에 넣을 수 없어 온라인 알고리즘이 필요하다는 어려움이 있음. 이 연구에서는 두 스트림의 동치를 증대적으로 비교하는 알고리즘을 제시. 이를 구현하고 버그를 잘 찾을 수 있으며 거짓 양성이 많지 않음을 실험적으로 확인함.

### Polymorphic types and effects with Boolean unification
이 연구에서는 불 제약 조건을 제공하는 다형 타입 및 효과 체계를 제시. 이 체계는 HM을 확장함과 동시에 가장 일반적 타입의 존재를 유지. 알고리즘 W를 연속적 변수 제거 알고리즘에 기반한 불 통합을 통해 확장해 타입 추론 알고리즘을 제시. 불 통합 문제는 원래 NP 난해이나, 타입 추론 알고리즘이 현실 세계의 프로그램에 적용되었을 때 합리적인 시간 안에 끝난다는 것을 확인.

### CAMP: cost-aware multiparty session protocols
시간과 메모리 같은 자원의 사용량을 알아내는 것은 중요. 이 연구에서는 동시성 및 분산 시스템의 성능 분석을 정적으로 수행해 성능의 병목이 되는 지점을 찾는 정적 분석 프레임워크인 CAMP를 제시. CAMP는 비결정성과 현실성이라는 두 어려움을 해결. 동시성/분산 시스템의 행동은 비결정적이며, 이를 해결하기 위해 다자간 세션 타입(MPST)을 사용. MPST는 분산된 참여자들 사이의 통신 구조, 즉 프로토콜을 표현하여 이를 바탕으로 한 성능 분석을 가능하게 함. CAMP는 존재하는 구현이 따르는 하나의 전역 타입만을 요구하기 때문에 기존 구현에 바로 적용될 수 있음.

### The anchor verifier for blocking and non-blocking concurrent software
동기화에 기반한 동시성 시스템의 올바름을 논증하는 것은 어려운 일이며, 여러 도구가 제시되었지만 제한된 종류의 동기화만 사용 가능하거나, 프로그래밍 모델이 현실과 거리가 멀거나, 많은 시간과 노력이 필요한 등의 한계가 있음. 이 연구에서는 동시성 소프트웨어 검증 도구인 ANCHOR를 제시. 이 연구에서는 프로그램에서 사용된 동기화 메커니즘을 분명하고 간결하게 명시할 수 있는 방법과 동기화 명세를 동작의 올바름을 검증하는 데 사용하는 방법을 제시. 동기화 메커니즘 명세는 각 메모리 공간에 언제 접근 가능한지와 접근 사이에 순서를 어떻게 바꿀 수 있는지 설명하는 것을 통해 이루어짐. 이를 바탕으로 선점형(preemptive) 스케줄러에서 작동할 때와 비선점형(cooperative) 스케줄러에서 작동하면서 yield로 표시된 곳에서만 문맥 교체(context switch)가 이루어질 때의 동작이 같음을 보장.

### Automatic and efficient variability-aware lifting of functional programs
소프트웨어 제품 라인(SPL)은 공통된 아티팩트로부터 함께 만들어진 소프트웨어 제품의 모임으로, 특정 기능이 어떤 제품에 있을 수도 있고 없을 수도 있음. 일반적인 분석 도구는 소프트웨어 하나를 받아 그에 대한 결과를 냄. SPL의 모든 제품을 분석하려면 경우의 수가 너무 많아 비효율적. 변동성 의식 분석(variability-aware analysis)은 기존 분석의 의미를 보존하면서도 여러 제품으로부터 온 입력에 동시에 적용 가능하여, 여러 제품 사이의 공통점을 활용해 분석 비용을 최대한 줄임. 이 연구에서는 주어진 분석 프로그램 G를 SPL을 입력으로 받는 프로그램 G↑으로 자동으로 다시 쓰는 일반적인 두 방법을 제시. 첫 방법은 얕은 리프팅으로, G를 블랙박스로 두고 변동성 의식 매개변수를 전달하는 식으로 G↑을 만듦. 두 번째 방법은 깊은 리프팅으로, 다시 쓰기 규칙을 바탕으로 동치인 변동성 의식 분석기를 만들어 공통점을 활용할 가능성을 높임.

### A sparse iteration space transformation framework for sparse tensor algebra
희소 텐서 대수 컴파일러는 밀집 텐서의 경우와 달리 반복 공간 변형 프레임워크(iteration space transformation framework)가 없음. 이로 인해 타일링, 병렬화, 벡터화, 정적 로드밸런싱 같은 중요한 최적화 기술을 사용하지 못함. 이 연구에서는 밀집과 희소 반복 공간 모두를 위한 통합된 희소 반복 공간 변형 프레임워크를 제시.

### Programming with a read-eval-synth loop
이 연구에서는 REPL과 유사한 대화형 환경에서 최종 사용자가 프로그램을 합성할 수 있는 모델인 RESL(read-eval-synth loop)을 제시. RESL을 만드는 것에는 두 가지 어려움이 있음. (1) 사용자가 자신의 의도를 표현하기 위한 올바른 상호작용 모델이 필요. (2) 상호작용 세션으로부터 얻은 정보를 합성기가 최대한 활용하여 효율적으로 합성해야 함. RESL은 사용자가 입/출력 값에만 의존하지 않고 예상되는 프로그램에 문법적 제한을 둠으로써 의도를 표현할 수 있게 함. 이런 명세 메커니즘은 관찰 동치와 같은 기존의 탐색 공간 가지치기 방식에 간섭하기 때문에, 관찰 동치를 확장해 합성을 효율적으로 만듦. 사용자 조사를 통해 RESL이 개발자에게 실제로 도움된다는 것을 확인.

### LiveDroid: identifying and preserving mobile app state in volatile runtime environments
모바일 애플리케이션은 휘발성 있는 실행 환경을 가짐. 휴대전화가 회전해서 화면을 다시 그릴 때 액티비티를 다시 시작한다거나, 자원이 부족해서 실행 중인 앱이 종료되었다가 사용자가 돌아 오면 다시 실행될 때 등. 사용자의 진행도를 잃거나 상태의 일관성을 잃지 않으려면 어떤 프로그램 변수나 GUI 원소의 성질이 저장/복구되어야 함. 이를 올바르게 구현하기 어렵기 때문에 여러 실제 애플리케이션에서 버그가 발생. 기존 연구는 해당 버그를 탐지하려 했으나 애플리케이션의 필요 인스턴스 상태(necessary instance state)를 어떻게 찾는지 대답하지 못하는 등의 한계가 있음. 이 연구에서는 안드로이드 애플리케이션의 콜백을 세 종류로 나누고 이를 바탕으로 접근 경로에 대한 두 요구 사항을 정의. 정적 분석을 통해 필요 인스턴스 상태를 결정하고 버그를 탐지.

### Towards a unified proof framework for automated fixpoint reasoning using matching logic
고정점 논증의 자동화는 다양한 수학적 구조에서 탐구되어 왔으나, 고정점 논증의 자동화를 위한 통합된 프레임워크는 아직 없음. 이 연구에서는 대조 논리(matching logic)을 바탕 논리로 한 고정점 논증 자동화를 위한 통합된 프레임워크를 제시하고, 여러 논리 체계에 적용.

### Adversarial examples for models of code
기계 학습 모델을 통해 메서드의 이름을 예측하거나 특정 종류의 버그를 찾을 수 있음. 이 연구에서는 해당 모델들이 적대적 예시(adversarial example)에 취약함을 보이고 학습된 모델들을 적대적 예시를 통해 공격하기 위한 새로운 방법을 제시. 주어진 학습된 모델이 잘못된 예측을 하게 만들기 위해 프로그램의 의미를 바꾸지 않는 작은 변화를 코드에 추가. 그런 변화를 찾기 위해 DAMP(discrete adversarial manipulation of programs)를 위한 새로운 기술을 제시.

### Towards a formal foundation of intermittent computing
임베디드 컴퓨팅의 각광받는 분야는 EHD(energy-harvesting device)로, 전지 없이 태양광 등을 통해 환경에서 에너지를 공급받아 작동하며, 어떤 EHD는 에너지가 충분히 모였을 때만 간헐적으로 계산을 수행. 이런 간헐적 실행 모델하에서는 예측할 수 없는 시점의 정전으로 인해 메모리가 일관적이지 않은 상태에 놓일 수 있는 등의 문제가 있음. 기존 연구에서 제시한 모델은 반복적인 입력을 수행할 때 문제가 있음. 이 연구에서는 간헐적 실행 모델을 정형화하고 시스템읠 올바름을 증명하기 위한 불변성질을 제시.

### Compiling symbolic execution with staging and algebraic effects
기호 실행은 널리 사용되는 기술이나 올바르고 효율적인 기호 실행 엔진을 구현하는 것은 어려움. 동시에, 기호 실행 엔진은 여러 실행 전략을 지원하도록 유연해야 함. 기존 연구에서는 정의적 인터프리터(definitional interpreter)를 바탕으로 기호 실행기를 만들어 올바름을 보장하거나 계측(instrumentation)을 통해 프로그램을 기호 실행을 하도록 변형해 성능 향상을 이루는 방식이 제안. 이 연구에서는 기호 실행의 비결정성과 SMT 등을 효과와 처리기로 간주하여 정의적 인터프리터로부터 기호 정의적 인터프리터를 만들고 스테이징을 통해 계측을 하는 방법을 제시. 댜앙한 실행 전략이 효과와 처리기로 구현될 수 있기 때문에 이 방식은 유연함.

### Testing differential privacy with dual interpreters
차등 정보 보호에 대한 증명이 올바른지 확인하기 어려움. 기존 연구에서는 차등 정보 보호를 검증하는 작업을 부분적으로나 완전히 자동화하려고 노력. 이 연구에서는 프로그래머에게 어떤 표시도 요구하지 않으며 기존 연구의 벤치마크 알고리즘을 처리할 수 있는 차등 정보 보호 검증을 위한 DPCheck라는 프레임워크를 제시. 계측된 실행과 기호 실행으로부터 얻은 정보를 합해 특정 실행에 대한 보호 증명을 만들고, 많은 실행들을 얻은 증명들을 다시 합쳐 차등 정보 보안에 대한 통계적 보장을 얻을 수 있다는 것이 핵심 발상.

### Verifying and improving Halide’s term rewriting system with program synthesis
Halide로 작성된 이미지 처리 파이프라인을 컴파일하기 위해 컴파일러는 항 다시쓰기 체계(term rewriting sytem)를 사용. 정해진 규칙을 주어진 파이프라인에 반복적으로 적용하여 파이프라인을 단순화. 규칙들의 건전성은 증명되지 않았기에 원하지 않는 동작을 초래할 수 있음. 이 연구에서는 존재하는 규칙들을 SMT 해결기와 Coq으로 정형 검증하여 건전성을 증명하거나 불건전한 규칙을 찾음. Halide 항 다시쓰기 체계의 맥락에서 단순화가 무엇인지 정의하여 항 사이의 순서를 정하고 알고리즘의 종료를 보장함. 새로운 규칙들을 합성함.

### Dynamic dispatch of context-sensitive optimizations
문맥 둔감 컴파일러 최적화에 비해 문맥 민감 최적화는 다양한 경우에 크게 더 정확. 문맥 민감 최적화를 사용하는 일반적인 방법은 모든 문맥에 대해 변형이 안전함이 보장되었을 때 최적화를 하는 것이지만, 함수 인라이닝이나 복제를 통해 안전함이 보장된 특정 문맥에서만 최적화를 하는 것이 더 좋음. 이는 코드 크기를 키우기에 제한적으로 사용됨. 최적화된 함수만 복제되는 것이 아니라 그 함수에 도착하기까지의 모든 경로가 복제되어야 함. 이 연구에서는 호출 문맥을 추적하기 위한 암묵적인 상태 기계를 사용하는 것을 통해 코드 크기 폭발을 억제하는 문맥 민감 최적화를 제시. 이를 통해 최적화된 함수에 도달하기 위한 경로의 길이에 상관 없이, 가능한 최적화의 수에 따라 함수가 복제됨. 코드가 아닌 자료 구조만 커짐.

### Eliminating abstraction overhead of Java stream pipelines using ahead-of-time program optimization
Java 8에서 여러 함수형 기능들이 추가되었고 그중 하나는 스트림. 스트림을 사용한 선언형 프로그래밍은 명령형 프로그래밍에 비해 설계 측면에서 강점을 가지지만, 성능 저하 때문에 실제로 잘 사용되지 않으며, Java의 여러 번에 걸친 업그레이드에도 불구하고 벤치마크에 따라 최대 수십 배에 달하는 성능 저하가 여전히 존재. 이 연구에서는 AOT 최적화를 통해 자바 스트림의 성능을 개선. 타입과 포인터 분석을 동시에 수행하는 정적 분석을 제시. 정적 분석을 바탕으로 메서드 인라이닝과 스택 할당을 통한 바이트코드 최적화 수행. 제시한 최적화를 통해 10 배 또는 그 이상의 성능 향상을 이룰 수 있음을 확인.

### Build scripts with perfect dependencies
올바른 의존성을 가진 빌드 스크립트를 작성하는 것은 어려운 일. 동시에, 의존성을 명시한 빌드 스크립트 덕분에 증대적이고 병행적인 빌드가 가능. 이 연구에서는 사람이 의존성을 고려해 빌드 스크립트를 작성하기보다 전체 빌드 과정 명령을 담고 있는 하나의 셸 스크립트로부터 증대적이고 병행적인 빌드를 가능하게 만드는 기술을 제시. 파일 입출력을 추적하여 파일 사이의 의존성을 자동으로 찾을 수 있음. 병행적 빌드를 위해 예측(speculation)을 사용하여 어떤 미래의 명령이 이미 실행 중인 명령과 간섭하지 않을지 추측. 이 과정의 핵심은 간섭이 무엇인지 강건한 모델을 정의하는 것. 기술을 사용해 RATTLE이라는 빌드 체계를 구현하고 MAKE 스크립트와 RATTLE 스크립트를 비교하는 등의 실험을 진행함.

### Deductive optimization of relational data storage
정적 데이터베이스는 데이터가 느리게 바뀌거나 아예 바뀌지 않고, 사용하는 쿼리의 종류가 사전에 고정된 데이터베이스. 일반적인 데이터베이스를 사용해도 되지만 이는 최적화와 특화의 기회를 잃게 함. 이 연구에서는 정적 데이터베이스를 만들기 위한 도메인 특화 언어 CASTOR와 컴파일러를 제시. 정의한 레이아웃 대수를 통해 메모리에 존재하는 데이터의 레이아웃을 표현할 수 있으며, 이를 사용해 쿼리의 동작과 데이터 레이아웃을 바꾸는 연역적 변형이 가능. CASTOR는 자동화된 연역적 최적화를 제공.

### Program equivalence for assisted grading of functional programs
프로그램이 동치인지 판단한 뒤 교수자가 동치인 모든 제출물에 대해 한번에 피드백을 제공할 수 있다면 많은 학생이 수강하는 과목의 과제 피드백 제공에 도움이 됨. 이 연구에서는 임의의 두 프로그램이 알고리즘적으로 유사한지 판별하는 기술을 제시. 기계 학습 문헌에서 사용되는 클러스터링 대신 정형 방법을 사용하였기에 건전성(동치로 판별된 두 식의 동작이 같음)이 증명됨. 이 기술은 주어진 식의 쌍을 동시에 분해한 뒤 두 식이 동치일 때만 유효한 공식을 만들어 냄으로써 동치 여부를 판단. 정의한 여러 추론 규칙을 통해 식을 원자 부분식으로 분해하며 공식의 유효성을 검사하기 위해 SMT 해결기를 사용.

### A modular cost analysis for probabilistic programs
자원 분석은 자원의 사용을 분석하는 정적 분석의 하위 분야. 완전 자동화된 자원 분석에 많은 발전이 있었으며 그 핵심은 모듈성. 모듈성을 통해 각 코드 조각들이 독립적으로 분석될 수 있어 분석의 정확도에 영향받지 않고 분석의 속도를 개선할 수 있음. 비결정적 및 확률적 프로그램이 각광받고 있으나, 그런 프로그램의 자원 분석은 여러 어려운 점이 있음. 이 연구에서는 비결정적 및 확률적 명령형 언어의 자동화된 평균 실행 시간 분석을 제시. 이 연구에서 제시한 방식은 모듈적으로, 기존 기술보다 성능이 뛰어나고, 기존 기술로 분석할 수 없는 중요한 예제도 분석 가능.

### Geometry types for graphics programming
렌더링 프로그램들은 다양한 벡터 연산을 사용하지만 그런 연산의 기저에 있는 기하하적 성질을 프로그래밍 언어가 잘 표현할 수 없음. 예를 들면, 두 벡터의 차를 구하는 것은 두 벡터가 서로 다른 좌표계에 속한다면 잘못된 행동일 수 있음. 기하학적 버그는 확인하기 어려우며 테스트를 작성해 찾기도 어려움. 이 연구에서는 기하학적 버그를 없앨 수 있는 타입 체계와 생성 단계부터 버그를 없앨 수 있는 자동 변형 메커니즘을 제시. 기하 타입은 각 값을 표현하는 좌표계 및 그를 조작하는 변형을 나타냄. 각 기하 타입은 기준 프레임(reference frame), 기하학적 물체, 좌표 표현 방법(coordinate scheme)을 표현. Gator라는 기하 타입을 사용하는 언어를 설계해 기하학적 버그를 없애고 자동으로 올바른 변형 코드를 생성하도록 함.

### Hidden inheritance: an inline caching design for TypeScript performance
TypeScript는 JavaScript의 의미는 보존하면서 문법을 확장해 정적 타입 검사를 가능하게 하며 최근 널리 사용됨. 프로그래머들은 TypeScript의 OO 방식 프로그래밍 패턴을 많이 사용하며, OO 방식 프로그램에는 상속을 통한 다형성이 흔함. 다형성으로 인해 객체의 프로퍼티에 접근하기 전에 객체의 타입을 알아야 하므로 현대 JavaScript VM의 핵심 최적화인 IC(인라인 캐싱)의 성능을 떨어트림. 이 연구의 목표는 다형성으로 인한 IC 미스를 줄이고 OO 방식 TypeScript 프로그램의 성능을 향상시키는 것. 레이아웃 일관성을 바탕으로 HI(hidden inheritance)라는 인라인 캐싱 설계를 제안. HI의 핵심 발상은 향상된 인라인 캐시를 만들기 위해 정적 타입 정보를 최대로 활용해 정적으로 숨겨진 클래스를 생성하는 것.

### A type-and-effect system for object initialization
객체 지향 언어에서 객체 초기화의 안전성(필드가 초기화되기 전에 사용되지 않음)을 확인하는 것은 중요하지만 어려움. 생성자 안에서 this 사용을 허가하고 순환이 있는 자료 구조를 만들 수 있어야 함. 가상 메서드 호출, 별명, 타입 상태 다형성 등으로 인해 분석이 어려움. 현존하는 언어는 초기화 안전성을 전혀 검사하지 않거나 검사하는 대신 과도한 제약을 부여. 기존 연구에서 제안한 기술은 문법적 부담을 추가. 이 연구에서는 초기화의 지역적 논증에 대한 더 나은 이해와 기존의 자유(freedom) 모델보다 더 표현력이 뛰어난 타입 기반 모델을 제시하며, 새로운 타입 및 효과 추론 체계를 도입.

### Sound garbage collection for C using pointer provenance
메모리를 수동으로 관리하는 것은 해제 후 사용과 메모리 누수 등의 문제를 일으킴. GC는 시간적 메모리 안전성을 보장하여 프로그래머의 부담을 줄이지만 C/C++ 같은 약타입 언어를 위한 건전한 GC는 기존에 제시되지 않았음. 건전한 GC는 이후에 사용될 객체를 해제하지 않음을 보장. C/C++에서 포인터 값은 포인터가 아닌 변수에 저장되거나 그런 변수로부터 계산되어 얻어질 수 있으므로 건전한 GC가 어렵고, 기존 연구는 값 기반 휴리스틱을 제시했지만 건전한 방법은 아님. 이 연구에서는 Prov-GC(기원 기반 GC)라고 불리는 C/C++를 위한 최초의 건전한 GC를 제시. 핵심 발상은 포인터가 아무 곳에서나 만들어지는 것이 아니라 malloc 등의 할당 함수와 주소 연산자(&)로부터만 얻어질 수 있다는 것. 동적 정보 흐름 추적을 통해 포인터로부터 만들어진 값을 저장하는 공간을 건전하고 정확하게 알아냄. 하이브리드 오염(taint) 분석을 통해 동적 정보 흐름 추적을 최적화 가능.

### Dataflow-based pruning for speeding up superoptimization
초최적화(superoptimization)은 주어진 최적화되지 않은 코드를 명세로 보고 해당 명세를 따르는 효율적인 프로그램을 합성하는, 여러 단계의 변형에 의존하는 기존의 최적화와 차별화된 컴파일 기술. 합성해야 하는 코드가 길수록 탐색 공간이 커져 어려움. 잘못된 후보들을 빠르게 폐기하는 것이 중요. 이 연구에서는 정방향 및 역방향 데이터 흐름 분석을 통해 합성 후보들을 가지치기하는 프레임워크를 제안. 분석을 통해 명세와 후보의 성질을 계산하고 둘 사이의 모순을 찾음.

### FlowCFL: generalized type-based reachability analysis: graph reduction and equivalence of CFL-based and type-based reachability
도달 가능성 분석은 소스에서 싱크로 가는 흐름을 탐지. 이 연구에서는 타입 기반 도달 가능성 분석인 FlowCFL을 제시. 두 종류의 타입 pos와 neg가 있고 neg에서 pos로 가는 흐름만 허용. FlowCFL은 pos에서 neg로 가는 흐름이 있는지 검사. 흐름의 의미는 고전적인 CFL(문맥 자유 언어) 도달 가능성. 그래프 G_BI를 만들어 CFL 도달 가능성을 계산. 그러나 CFL 도달 가능성이 모든 프로그램 흐름을 포착하는지 형식적으로 확인지지 않음. 이 연구에서는 흐름이라는 개념을 정형화하는 동적 의미를 제시하고 G_BI에 대한 CFL 도달 가능성이 모든 실행 시간 흐름을 포착함을 증명.

### Learning graph-based heuristics for pointer analysis without handcrafting application-specific features
포인터 분석을 빠르고 정확하게 하려면 좋은 분석 휴리스틱이 필요. 예를 들어, 어느 메서드에 깊은 수준의 문맥 민감도를 적용할지 결정하거나, 어느 힙 객체에 타입 기반 요약 대신 할당 위치 기반 요약을 적용할지 결정해야 함. 기존 연구에서는 그래프 기반 분석 휴리스틱을 사용. (1) 먼저 값싼 전분석을 통해 주어진 프로그램에 대한 그래프 표현을 생성한 뒤 (2) 그래프 구조에 대해 논증한 것을 바탕으로 본분석을 위한 프로그램 특화 정책을 만듦. 이 연구에서는 그래프 기반 분석 휴리스틱을 만드는 것을 자동화하는 기술을 제시. 기존의 그래프 기반 휴리스틱은 전문가에 의해 수작업으로 설계된 것과 달리, 이 기술을 사용하면 사람의 노력 없이 주어진 그래프로부터 휴리스틱을 자동으로 만들 수 있음. 그래프 구조를 묘사하는 특성(feature) 언어와 해당 언어에 대해 분석 휴리스틱을 학습하는 알고리즘을 개발함.

### Knowing when to ask: sound scheduling of name resolution in type checkers derived from declarative specifications
선언적인 명세로부터 타입 검사기를 올바르게 만드는 데 어려운 점 중 하나는 이름 해결(name resolution). 프로그램에 있는 이름은 타입 검사 과제 사이의 의존성을 만들고, 심볼 테이블의 생성이 해당 데이터에 대한 쿼리와 번갈아 일어나게 만듦. 쿼리를 너무 일찍 계산하면 이후에 심볼 테이블에 추가되는 내용에 의해 쿼리 결과가 무효화되므로 그 결과는 불안정. 안정된 결과를 얻으려면 관련된 모든 정보가 수집된 후에 쿼리를 해결해야 하며, 올바르게 타입 검사기를 구현하기 어려움. 이 연구에서는 이름 쿼리의 안정성을 보장하기 위한 필요 충분 조건의 언어 무관한 설명을 제시. 언어의 정적 의미를 정의할 수 있는 메타 언어인 Statix의 범위 그래프(scope graph)를 사용. 범위 그래프의 중요 모서리(critical edge)를 도입. Statix-core를 정의하고 안정성이 보장되도록 쿼리 스케줄을 만드는 Statix-core의 연산 의미를 제시. Haskell, Java, Scala, Rust 타입 체계의 핵심을 Statix-core로 구현.

### Designing types for R, empirically
R은 데이터 분석을 위해 널리 사용되는 언어로, 정적 타입 체계가 없음. R을 위한 타입 체계를 설계하기 위해서는 R 코드를 정확하게 타입 검사하기 위해 어느 정도의 표현력이 필요한지와 R 커뮤니티가 채택하고 싶은 타입 체계가 무엇인지 알아야 함. 이 연구에서는 R의 데이터 타입과 맞는 단순 타입 언어를 설계하고 널리 사용되는 오픈 소스 R 라이브러리로부터 함수들의 타입 시그너처를 추출. 각 함수를 계측하여 추출한 타입 시그너처의 강건성을 입증.

### Shiftry: RNN inference in 2KB of RAM
ML 알고리즘을 IoT 기기에서 실행하기에는 IoT 기기의 작은 RAM과 Flash 메모리 크기가 문제. 이 연구에서는 부동소수점 ML 모델을 입력받아 주어진 메모리 제약에 맞는 고정소수점 코드를 만드는 컴파일러인 SHIFTRY를 제시. (1) 고정소수점 코드를 만들려면 각 변수에 대한 비트 폭(bitwidth)와 축척(sclae)을 정해야 함. 데이터 유도 방식으로 축척을 정하고 확인 집합을 통해 정확성이 얼마나 손실되는지 확인해 가며 변수 중 일부를 16 비트에서 8 비트로 강등시킴. (2) RAM 제약을 해결하는 방법으로는 모든 임시 변수를 스택에 할당하는 것과 동적 할당을 사용하는 것이 있음. 두 방법 모두 한계가 있기에 SHIFTRY는 모든 변수의 크기와 모양이 컴파일 시간에 알려져 있다는 성질을 공략해, 정적으로 동적 할당을 시뮬레이션함. SHIFTRY를 RNN에 적용해 보고 평가함.

### StreamQL: a query language for processing streaming time series
최근 많은 곳에서 스트리밍 데이터(실시간으로 빠르게 생성되는 데이터)를 처리해야 함. 스트리밍 시계열(제한되지 않은 수의 데이터 아이템을 가질 수 있는, 증가하는 시간 순으로 도착하는 데이터 스트림)을 처리하기 위한 고수준 명세를 작성하기 위한 언어의 지원이 부족. 대개 C나 C++ 등의 저수준 명령형 언어로 작성되며 이는 어렵고 오류를 유발하기 쉬움. 기존의 접근 방법은 모든 필요한 요약을 제공하지 않음. 이 연구에서는 StreamQL을 제시. StreamQL은 관계적(거르기와 매핑 등), 데이터 흐름(순차적 및 병렬적 구성), 시간적 요약을 제공.

### Incremental predicate analysis for regression verification
소프트웨어는 생명 주기 동안 지속적으로 수정되며, 각 수정마다 정형 검증되는 것이 이상적이지만, 회귀 검증(regression verification)은 많은 비용이 듦. 수정 후에 백지 상태에서 새로 검증을 시작하기보다는 수정 전의 검증에 사용된 정보를 사용하여 검증하는 것이 바람직. 이 연구에서는 술어 분석을 표명 표시로 재구성하고 표명 표시를 회귀 검증의 중간 결과로 사용. 가벼운 충격 분석(impact analysis)과 술어 분석에서 표명을 사용해 강화하는 기술을 제시.

### Perfectly parallel fairness certification of neural networks
기계 학습을 통해 만들어진 소프트웨어는 학습 데이터에 직·간접적으로 포함된 편향(bias)을 재생산하거나 강화할 수 있음. 이 연구에서는 표 형태의 데이터의 분류를 위해 사용되는 순방향 신경망(feed-forward neural network)의 공평성(fairness)를 검증하기 위한 새로운 정적 분석 프레임워크를 제시. 이 연구에서 사용한 공평성의 정의는 의존 공평성(dependency fairness)으로, 편향이 있을 것으로 간주되는 주어진 입력 특성에 대해, 신경망이 공평하다는 것은 출력된 분류가 주어진 특성의 서로 다른 값에 의해 영향받지 않는다는 것. 제시한 정적 분석은 정방향과 역방향 정적 분석을 결합. 정방향 단계에서는 신경망을 독립적인 분할로 나누어 전체 분석 비용을 줄이고, 역방향 단계에서는 완전 병렬적인 방식으로 각 분할의 공평성을 검증하려고 시도.

### Fuzzing channel-based concurrency runtimes using types and effects
Go와 같은 많은 최신 프로그래밍 언어는 채널과 프로세스를 바탕으로 한 동시성 프로그래밍을 지원. 언어 사용자에게는 채널과 프로세스가 동시성 프로그램을 단순화하는 개념이지만, 그 언어에 대한 컴파일러나 런타임을 구현하는 것은 어려움. 구현은 잠금을 통해 보호되는 공유 메모리 동시성에 의존하며, 경쟁 상태나 교착 상태의 가능성이 존재. 이 연구에서는 그런 컴파일러나 런타임을 자동으로 테스트하는 방법을 제시. 핵심 발상은 반드시 종료되어야 하는 흥미로운 프로그램을 자동으로 만들어낸 뒤, 그 프로그램이 실제로 종료되는지 확인하는 것. 반드시 종료되는 프로그램을 만들기 위해 채널과 프로세스를 포함한 대수를 위한 타입 및 효과 체계를 정의하고, 프로그램 종료가 보장된 효과의 부분 언어를 설계. 흥미로운 프로그램을 만들기 위해 다양한 휴리스틱을 사용. 실제로 구현하고 현실 세계 언어에서 새 버그를 찾음.

### Detecting locations in JavaScript programs affected by breaking library changes
최신 JavaScript 애플리케이션들은 서드 파티 라이브러리에 의존하며, 라이브러리가 호환성이 손상되도록 업데이트되면 그에 맞게 코드를 수정해야 할 수 있음. 제공된 라이브러리 수정 내역을 바탕으로 코드에서 수정해야 할 지점을 찾는 것은 오래 걸리고 실수하기 쉬운 작업. 해당 작업을 돕는 도구는 매우 제한적으로 존재하며 여전히 많은 수작업을 요구. 이 연구에서는 JavaScript 클라이언트 개발자들이 라이브러리의 호환성 손상 변화(breaking change)에 따라 코드를 수정하는 것을 돕는 반자동화된 방법을 제시. 라이브러리 개발자들은 연구에서 제시한 패턴 기반 언어를 통해 호환성 손상 변화에 영향받는 API 지점을 명시해야 함. 이는 수작업을 요구하지만 원래 작성하던 수정 내역으로부터 쉽게 만들 수 있음. 가벼운 정적 분석을 통해 패턴 대조를 수행하여 클라이언트 코드에서 해당 패턴에 맞는 지점을 찾음. 거짓 음성을 만들지 않는 것에 초점을 두었으며, 실험에서 거짓 음성이 발견되지 않음.

### Rethinking safe consistency in distributed object-oriented programming
분산 시스템에서 데이터 가용성을 높이고 접근 시간을 줄이기 위해 데이터를 복제하지만, 복제된 데이터를 동기화하는 것은 큰 비용이 들기에 약한 일관성 모델이 널리 사용됨. 어떤 연산은 올바름에 대한 요구가 크고 강한 일관성이 필요. 개발자들은 약한 일관성 데이터 저장소를 사용하되 일부 연산은 수작업으로 구현해 강한 일관성을 부여. 이 연구에서는 일관성과 가용성이 객체 지향 프로그래밍 모델과 통합된 언어인 ConSysT를 제시. 가용성이 필드, 참조, 중첩된 객체 등의 객체 요약과 어떻게 상호 작용하는지 탐구. ConSysT는 두 직관을 바탕으로 함. (1) 일관성과 독립성을 함께 고려. (2) 올바름에 대한 제약을 어기지 않음을 강제하는 타입 체계를 채택.

### DynamiTe: dynamic termination and non-termination proofs
종료는 실용적으로 중요한 이론적 성질로 선형 산술 대입과 반복문 가드가 있는 프로그램의 종료/비종료를 증명하는 데 효과적인 여러 도구 존재. 정적 검증을 돕기 위해 동적 실행을 바탕으로 한 기술을 사용하기 시작. 비선형적 프로그램의 불변 성질을 학습하기 위해 동적 분석을 사용하기도 함. 이 연구에서는 비선형적 프로그램의 불변 성질 학습을 위한 동적 실행 활용이 종료/비종료 논증에 어떻게 사용될 수 있는지 탐구. 종료/비종료를 증명하기 위한 정적/동적 혼합 전략을 사용하는 알고리즘을 제시.

### Precise static modeling of Ethereum “memory”
Ethereum 스마트 계약의 올바름을 보장하는 것은 중요하기에 여러 정적 분석이 시도됨. 대부분의 정적 분석 도구는 소스 코드 없이도 분석이 가능하도록 이진 코드 수준에서 작동. 이를 위해 디컴파일러를 사용. 디컴파일러는 비교적 성공적이나, 일부 저수준 개념들이 제대로 다루어지지 않음. 그중 하나는 일시적(transient) EVM 메모리를 정확히 모델링하는 것. Solidity 컴파일러는 가스 사용을 줄이는 메모리 관리 정책을 사용하지만, 이는 저수준에서만 존재하고, 소스 코드 수준에서는 메모리가 암묵적인 개념으로, 값들은 동적 길이 배열이나 문자열 등에 저장됨. 이 연구에서는 EVM 메모리를 정적으로 모델링하는 문제를 제시하고, 비상수 메모리 주소와 다른 데이터의 기호적 관계를 인식하는 흐름 분석을 바탕으로 한 메모리 모델링 방법을 제안.

### Taming type annotations in gradual typing
점진적 타입 체계를 사용할 때 코드에 타입 표시를 추가하는 작업은 어려움. 잘못된 타입 표시를 추가하면 정적으로 실수가 탐지되지 않지만 프로그램을 실행했을 때 타입 변환이 실패할 수 있음. 이런 문제는 테스트를 통해 발견되지 않을 수 있고, 발견했어도 타입 표시를 올바르게 수정하기 어려움. 이 연구에서는 잘못된 타입 표시를 정적으로 찾고 수정을 제안하는 기술을 제시. 동적 타입(⋆)으로 가려진 실제 값의 타입을 복구하는 것을 통해 잘못된 타입 표시를 찾을 수 있음. 올바른 수정을 자동으로 찾는 것이 어려움. 잘못하면 너무 많은 타입 표시를 없애거나 탐색 공간이 너무 넓어짐. 이 연구에서는 변화 타입(variational type)을 기반으로 해결책을 제시. 특정 타입 표시를 다른 정적 타입으로 바뀌었을 때 전체 타입 검사에 미치는 영향을 매번 새로 전부 계산하는 것이 아니라 해당 타입 표시에 변화 타입을 사용해 한번 계산한 영향을 재사용할 수 있음.

### Inter-theory dependency analysis for SMT string solvers
문자열 제약에 대한 자동화된 논증은 중요. 문자열 등식만을 가진 계는 Makanin의 결정 과정에 따라 해결 가능. 계가 길이와 contains, index_of, replace 등의 확장된 제약을 포함하는 경우 어려움. 길이를 포함하는 계의 결정 가능성은 알려지지 않았으며 확장된 제약까지 있는 계는 결정 불가능. 제약 사이의 상호 작용 때문에 어려움. 길이가 추가되면 상호 작용이 문자열 등식 사이에서만 일어나지 않고 정수 등의 다른 종류를 포함하기 때문에 이론 간 상호 작용/의존성이 발생. 특히 SMT 해결기는 서로 다른 종류의 제약을 각각 다른 이론 해결기로 풀기 때문에 여러 종류의 제약을 한번에 다루기 어려움. 이 연구에서는 의존성 분석을 통해 제약 사이의 이론 간 의존성을 해결하는 기술을 제시. 길이 제약과의 의존성을 끊기 위한 문자열 등식 사이의 부분 순서를 찾고 그 순서에 따라 해를 탐색.

### On the unusual effectiveness of type-aware operator mutations for testing SMT solvers
SMT 해결기는 다양한 곳에서 사용되는 중요한 도구로, SMT 해결기가 잘못된 결과를 내면 이에 의존하는 다른 도구의 결과가 무효가 되므로 SMT 해결기를 믿을 수 있게 만드는 것은 중요. 이 연구에서는 타입 의식 연산자 변이(type-aware operator mutation)를 통해 SMT 해결기의 버그를 찾아 냄. 주어진 공식에서 특정 연산자를 일치하는 타입의 다른 연산자로 바꾸어 변이를 만들 수 있으며, 이렇게 만든 변이를 Z3와 CVC4에 입력해 차등 테스팅(differential testing)을 할 수 있음. 이 기술을 구현한 OpFuzz를 만들었으며, OpFuzz는 1 년 동안 Z3와 CVC4에서 1092 개의 서로 다른 버그를 찾음.

### Pomsets with preconditions: a simple model of relaxed memory
완화된 메모리 모델은 프로그래머의 사용 용이성과 설계자들의 구현 유연성 사이의 균형을 잘 맞춰야 함. 프로그래머는 구성적이고 지역적인 논증을 원하고, 설계자들은 컴파일러 최적화를 유지하면서도 완화된 데이터 접근이 하드웨어 동기화를 요구하지 않기를 원함. 이를 모두 만족하는 모델을 만들기 어려움. 기존에 제시된 모델은 일부 경우에 원하지 않는 동작을 허용. 이 연구에서는 사람이 이해할 수 있는 두 발상인 사전 조건과 표식된 부분 순서(labelled partial order)를 바탕으로한 모델을 제시.

### Fast linear programming through transprecision computing on small and sparse data
많은 프로그램 분석과 최적화 기술은 선형 프로그래밍에 의존. 선형 프로그래밍 해결기가 수천 차원의 복잡한 문제를 잘 해결하도록 발정해 왔지만, 컴파일러 등에서 풀어야 하는 선형 프로그래밍의 특징은 작고 쉬운 문제가 매우 많다는 것. 그래서 컴파일러는 선형 프로그래밍 해결기의 발전의 덕을 별로 보지 못함. 이 연구에서는 컴파일러의 선형 프로그래밍을 목표로 한 해결기를 설계. 값이 작고 차원이 낮으며 희소성(sparsity) 높다는 특징을 공략. 초정밀(transprecision) 계산을 제안하고 작은 희소 행렬과 특화된 작은 계수 알고리즘의 최적화된 표현을 사용해 성능 향상을 실험적으로 확인함.

### Random testing for C and C++ compilers with YARPGen
컴파일러의 올바름을 확인하는 것은 중요한 일이며, 무작위 테스트 생성은 컴파일러 버그를 발견하는 효과적인 방법. 기존의 무작위 테스트 생성기는 언젠가는 포화 상태에 도달해 새로운 버그를 거의 찾지 못하게 됨. 이는 컴파일러가 실제로 버그가 없기 때문이 아니라 생성기가 컴파일러의 특정 부분만을 탐색하도록 편향되어 있기 때문. 이 연구에서는 C/C++ 프로그램을 위한 새로운 무작위 테스트 생성기인 YARPGen을 제시. YARPGen은 생성 정책(포화 상태를 막거나 늦추는 목표를 가진, 만들어진 코드의 문자를 체계적으로 바꾸는 메커니즘)을 지원하며, 정의되지 않은 동작이 없는 코드만을 만들면서도 기존 연구에서 사용한 무거운 래퍼나 언어 기능 제한 등의 방법에 의존하지 않음. 200 개 가량의 버그를 찾음.

### CompCertELF: verified separate compilation of C programs into ELF object files
소프트웨어 실행을 처음부터 끝까지 검증하려면 검증된 컴파일러가 소스 코드로부터 올바른 이진 프로그램을 만들어야 함. 컴파일러는 ELF 등의 형식을 따르는 목적 파일을 만들어야 하며, 분리된 컴파일을 지원해야 함. CompCert는 목적 파일을 만들지 않고 실제 어셈블리 프로그램과 의미가 일치하지 않는 Coq으로 정형화된 어셈블리 프로그램을 만듦. CompCert를 확장한 기존 연구인 Stack-Aware CompCert는 CompCert의 어셈블리 프로그램을 현실적인 어셈블리 프로그램으로 컴파일. 여전히 목적 파일로 컴파일하지 못하며, 닫힌 프로그램만 표현하므로 분리 컴파일을 제대로 할 수 없음. 이 연구에서는 C에서 목적 파일로 가는 검증된 분리 컴파일을 지원하는 CompCertELF를 제안. 검증된 어셈블러를 만들어 Stack-Aware CompCert의 어셈블리 프로그램을 ELF 파일로 변환. 컴파일이 두 개의 서로 다른 링커에 대해 교환 가능함을 증명함.

### Scalable and serializable networked multi-actor programming
분산 프로그램은 병렬성(각 부품이 독립적으로 실행)과 협력(collaboration, 여러 부품이 함께 작업)에 대해 논증할 수 있으면서도 성능이 좋아야 함. 이를 위해 행위자(actor) 모델이 널리 사용됨. 각 행위자가 독립적으로 작업하므로 병렬성이 만족되고, 메시지 전달을 통해 행위자 간 협력이 가능. 많은 경우, 개별 메시지에 대한 논증뿐 아니라 여러 메시지가 협력을 구성하는 경우에 대한 논증이 필요. 특히, 메시지 사이의 강한 일관성을 보장하는 것은 어려움. 이 연구에서는 강한 완결성을 추가하면서도 성능이 방해받지 않도록 하는, 새로운 행위자 기반 모델을 제시. 이 모델은 직렬성(serializability)을 제공. 행위자 간 통신 그래프가 DAG을 이룬다는 것이 가장 중요.

### Termination analysis for evolving programs: an incremental approach by reusing certified modules
프로그램 종료를 증명하려는 여러 연구가 있었지만, 진화하는 프로그램의 종료를 효율적으로 증명하는 방법에 대한 연구는 드물었음. 이 연구에서는 종료 증명을 위한 증대적 분석을 제안. 증명된 모듈(certified module)에 기반. 증명된 모듈은 모든 수락된  ω 트레이스가 종료되며, 트레이스들이 동일한 종료 논거를 공유함. 이 연구의 발상은 증명된 모듈이 재사용 가능하다는 것. 증명된 모듈의 생성은 프로그램 구조로부터 유도되는 대신, 트레이스를 인식함. 각 모듈은 여러 Hoare 세쌍으로 분해될 수 있고, 특정 블록에 대한 Hoare 세쌍은 그 블록이 바뀌지 않는 한 재사용 가능. 프로그램 변경은 블록 변경과 제어 흐름 변경으로 나눌 수 있으며, 제안한 방법은 두 종류의 변경을 모두 처리할 수 있음.

### Programming and reasoning with partial observability
부분적으로 관찰 가능한 환경에서 실행되는 프로그램을 정형 검증하려면, (1) 환경 모델(관찰과 계의 진짜 상태 사이의 관계)을 정형 명시하고 (2) 상태 근사기(state estimator)를 구현한 뒤 그 올바름을 검증하고 (3) 제어부를 구현한 뒤 환경 모델과 제어부의 조합이 계의 요구를 만족하는지 검증해야 함. 이 연구에서는 개발자가 환경 모델에 대한 명세를 작성하면 상태 근사기가 자동으로 제공되는 프로그래밍 방법론인 믿음(belief) 프로그래밍을 제시. 이를 위한 언어인 BLIMP를 제시. BLIMP로 작성된 프로그램의 성질을 검증할 수 있도록 Hoare 논리에 양상 명제들을 추가한 지식 Hoare 논리(epistemic Hoare logic)을 제시.

### Interactive synthesis of temporal specifications from examples and natural language
로봇이 할 일을 명시하기 위해 흔히 LTL(linear temporal logic)을 사용. LTL은 표현력이 높으면서도 모호함 없이 작업을 명시하지만, 비 전문가가 사용하기 어려움. 기존에 제한된 구조화된 자연어로 작성하는 LTL 명세는 여전히 LTL에 대한 이해를 요구하고, 대화 상자 기반 인터페이스는 표현력이 제한됨. 예시를 통한 명세 작성은 많은 긍정 및 부정 예시가 제공될 것을 요구. 이 연구에서는 자연어 설명과 단 한 개의 예시만을 입력받아 LTL 명세 후보들을 만들고, 반복적인 상호 작용을 통해 올바른 LTL 명세를 찾은 뒤, 매개화를 통해 명세를 일반화하는 기술을 제시.

### A large-scale longitudinal study of flaky tests
믿을 수 없는(flaky) 테스트는 같은 코드 버전에서 비결정적으로 성공하거나 실패하는 테스트로, 개발을 방해. 일부 기업에서는 어떤 테스트가 믿을 수 없는지 확인하기 위한 탐지기를 사용. 믿을 수 없는 테스트가 추가되거나 존재하던 테스트가 믿을 수 없게 되었을 때 개발자에게 바로 알려 주는 것이 바람직. 믿을 수 없는 테스트에 대한 연구는 잘 이루어지지 않음. 이 연구에서는 믿을 수 없는 테스트에 대한 대규모 종적 연구를 진행. 테스트가 언제 믿을 수 없어지는지 알기 위해 존재하는 탐지기를 사용했고 75%의 믿을 수 없는 테스트가 처음 추가되었을 때부터 믿을 수 없음을 확인. 이는 새로 추가된 테스트에 탐지기를 사용하는 것이 중요함을 의미.

### Differentially-private software frequency profiling under linear constraints
차등 정보 보호는 개인에 대한 정보를 누설하지 않으면서 의미있는 통계를 얻을 수 있게 하기에 널리 사용됨. 소프트웨어 프로파일링 분야에서도 차등 보안을 통해 여러 사용자의 프로파일링 데이터가 정보 보호를 유지하면서 수집 및 분석될 수 있음. 기존 연구에서는 정보 보호를 너무 제한적인 시각으로 바라보아 낮은 정확도의 통계를 얻게 함. 이 연구에서는 정보 보호를 빈도 벡터 수준에서 정의해도 충분하다는 관찰을 바탕으로 프로파일링을 위한 차등 정보 보호를 새로 정의하고 이를 달성하기 위한 새로운 메커니즘을 제안. 이를 통해 정보 보호를 많이 잃지 않으면서 프로파일링 결과의 정확도를 높일 수 있음을 실험적으로 확인.

### Do you have space for dessert? a verified space cost semantics for CakeML programs
메모리 수집기가 있는 고수준 언어는 컴파일러가 생성한 기계어 코드가 메모리가 모자르지 않는 경우에만 소스 코드의 의미를 따른다는 뜻의 부분성(partiality)을 보임. 특정한 경우, 프로그래머는 기계어 코드가 메모리 부족 오류 없이 실행되기 위해 필요한 메모리의 크기를 알고 싶음. 이 연구에서는 CakeML 컴파일러의 맥락에서 이 문제에 대한 증명 기반 접근을 제시. 부분성은 소스 코드의 생존 성질은 기계어 코드에서 보장되지 못하고, 오직 안전 성질만이 보장될 수 있음을 의미. 이 연구에서는 부분성을 없애 생존 성질 역시 보장할 수 있게 하는 is_safe_for_space 술어를 정의하고 컴파일러 증명을 확장. CakeML을 위한 정형 공간 비용 의미를 정의.

### Digging for fold: synthesis-aided API discovery for Haskell
함수형 언어 사용자들은 라이브러리에 존재하는 다형 및 고차 함수를 사용해 원하는 기능을 간결하게 구현할 수 있지만, 존재하는 함수들을 조합하는 방법이 매우 많기 때문에 올바른 방법을 찾기 어려움. 이 연구에서는 사용자가 타입이나 예시, 또는 둘 다를 제공하면 명세를 만족하는 함수를 라이브러리 함수로부터 자동으로 함성하는 도구인 HOOGLE+를 제시. HOOGLE+는 이전 합성에 대한 이전 연구인 타입 유도 요약 정제(type-guided abstraction refinement)를 사용. 이 연구가 해결한 어려움은 세 가지. (1) 사용자 명세를 작성할 때의 어려움을 해결하려고 예시로부터 타입을 합성하는 알고리즘 제시. (2) 합성을 통해 만들어진 많은 후보는 상수 함수와 같이 흥미롭지 않은 함수. 이를 자동으로 없애도록 성질 기반 테스팅(property-based testing)을 사용하는 휴리스틱 제시. (3) 합성된 프로그램이 원하는 프로그램인지 확인하기 어려우며, 예시를 제공할 수 있지만 유익하지 않은 예시가 많음. 성질 기반 테스팅을 통해 유익한 예시만 제공하는 방법을 제시.

### Resolution as intersection subtyping via Modus Ponens
서브타입, 교집합 타입, 병합 연산자(merge operator)를 통해 함수 오버로딩을 표현할 수 있음. 분별(resolution)은 Haskell의 타입 클래스와 Scala의 암묵 등에서 사용되는 메커니즘으로, 역시 함수 오버로딩을 표현할 수 있음. 분별의 핵심 기능은 여러 인스턴스를 조합하는 능력. 예를 들어 Over Int와 Over Int => Over [Int]가 있으면 Over[Int]를 얻을 수 있음. 이는 서브타입으로는 표현 불가능. 이 연구에서는 서브타입과 교집합 타입을 제공하는 타입 체계를 확장해 분별을 포함시킬 수 있음을 보임. 전건 긍정이 핵심 발상으로, A ⊢ B -> C이고 A ⊢B이면 A ⊢C라는 것을, A <: B -> C이고 A <: B이면 A <: C라는 규칙으로 사용. 𝜆i+를 확장했으며 서브타입의 추이성(transitivity)과 결정 가능성 및 의미의 일관성(coherence)를 모두 만족.

### World age in Julia: optimizing method dispatch in the presence of eval
동적 언어는 대개 동적 코드 불러오기를 가능하게 하는 eval을 지원. Julia의 eval은 최상위 수준에서 실행되며 eval을 통해 함수를 재정의하는 것은 현재 실행 중인 함수가 모두 끝나고 최상위 수준에 돌아갔을 때 반영됨. 이는 eval이 존재할 때도 함수를 역최적화할 필요 없이 역가상화(devirtualize), 특화(specialize), 인라이닝하는 것을 허용함. eval의 함수 정의 효과를 늦추는 이 메커니즘은 세계 나이(world age)라 불림. 이 연구에서는 세계 나이라는 개념을 요약하여 모델링하는 JULIETTE 대수를 도입했으며, Julia 컴파일러가 사용하는 세 가지 최적화를 형식화하고 올바름을 증명함.

### ιDOT: a DOT calculus with object initialization
DOT의 타입 건전성이 증명된 것과 달리, Scala 타입 체계는 초기화되지 않은 필드의 값이 null인 것으로 인해 건전하지 않음. DOT은 경로 의존 타입 대신 변수 의존 타입만 지원하고, pDOT은 경로 의존 타입을 지원하지만 객체 초기화를 위해 이미 존재하는 값을 사용할 것을 요구해 순환적 구조를 금지하며, 𝜅DOT은 생성자 및 필드 초기화까지 제대로 정의했으나 초기화 오류를 정적으로 탐지하지 않는 대신 오류가 발생하면 발산시킴. 이 연구에서는 𝜅DOT을 확장해 𝜄DOT을 정의. 𝜄DOT의 효과 체계는 초기화되지 않은 필드 사용을 탐지해 초기화 오류를 정적으로 탐지. 효과 체계는 기존 연구의 FBC(Freedom Before Commitment)와 DT(Delayed Type)으로부터 영감을 얻음. FBC는 각 객체를 free와 committed로 분류하며, DT는 힙을 시간 붙은 영역(timed region)으로 분할. DT의 발상을 FBC에 적용하여 FBC와 DT에는 없던 기계화된 건전성 증명을 제시.

### Taming callbacks for smart contract modularity
모듈(스마트 계약)이 다른 모듈의 메서드를 호출했을 때, 그 메서드에서 원래 모듈의 메서드를 호출할 수 있음. 이런 콜백 메커니즘은 프로그래머가 자신의 코드에 대한 호출의 인터리빙을 고려하게 만들기에 프로그램 논증을 복잡하게 하며 재진입(reentrancy) 공격을 가능하게 함. 이 연구에서는 문법적 제한 없이, 콜백의 올바른 사용을 허용하면서 재진입 공격이 불가능함을 증명하는 건전한 정적 분석을 제시. 정적 분석으로 모듈성, 즉 콜백 없는 프로그램이 콜백 있는 프로그램과 동치임을 증명하며, 이는 관계적 초성질이므로 어려움. 기존 연구에서 정의한 ECF(effectively callback free) 모듈로부터 영감을 받음. 교환성(commutativity) 검사를 통해 ECF를 정적으로 검증.

### Testing consensus implementations using communication closure
대규모 분산 시스템의 올바름을 테스팅하는 것은 어려움. 이 연구에서는 테스팅의 어려운 점 두 가지에 초점을 맞춤. (C2) 소수의 사용자 요청만 가지고도 이들을 임의의 방법으로 번갈아 실행함으로써 많은 실행을 만들 수 있음. 취약점을 드러낼 확률을 높이도록 실행을 나열하는 효율적인 전략이 필요. (C3) 한 취약점이 여러 방법으로 드러날 수 있으며, 원인과 해결책을 찾기 쉽게 만드는 쉽게 해석 가능한 실행을 우선적으로 보여 주는 것이 바람직. 이 연구에서는 버그는 손실 동기적 실행(lossy synchronous execution)에 이미 나타날 것이라는, 통신 종결(communication closure) 가설을 세우고 이 가설을 바탕으로 테스팅 알고리즘을 제시.

### Finding bugs in database systems via query partitioning
DBMS(database management system)에 SQL을 통해 데이터를 추가/삭제/수정/쿼리할 수 있음. 이 연구에서는 DBMS가 쿼리에 대해 잘못된 결과 집합을 내는 논리 버그를 고려. 쿼리 분할(query partitioning)이라는 일반적이고 효과적인 기술을 제시. RS(Q)라는 결과 집합을 내는 쿼리 Q로부터 RS(Q1), …, RS(Qn)의 조합이 RS(Q)와 같은 부분적인 쿼리들인 Q1, …, Qn을 만드는 것이 쿼리 분할. 만약 두 집합이 다를 시 논리 버그로 간주 가능. 이 연구에서는 삼항 논리 분할(ternary logic partitioning)을 제안. 한 술어는 주어진 행에 대해 TRUE, FALSE, NULL 중 하나를 결과로 내는 함수로 해석 가능. 175 개의 기존에 알려지지 않았던 버그를 5 개의 널리 사용되는 DBMS에서 발견함.

### Structure interpretation of text formats
임의의 형태(CSV, JSON, XML, 그 변종, 이들의 혼합 등)로 구조화된 텍스트 파일로부터 표 형태의 데이터를 추출하는 것은 프로그래머에게 장애물이 되는 작업. 프로그램 합성 기술의 발전으로 인해 이 문제에 대한 여러 해결책이 기존 연구에서 제시되었지만 특화된 알고리즘이나 도메인 특화 언어를 사용하기에 제한적인 문제만 해결 가능. 이 연구에서는 부분 구조(partial structure)에 대해 서로 다른 규칙들로 표현되는 데이터 추출 로직이 협력할 수 있게 함. 이 설계는 새로운 형태를 처리하도록 새 규칙을 추가하는 것이 적은 노력으로 가능하기에 프레임워크가 쉽게 확장될 수 있게함.

### Programming at the edge of synchrony
결함 감내(fault-tolerant) 분산 알고리즘은 설계하고 구현하기 어려움. 기존 연구에서는 기본 라운드(basic round) 모델을 제시해 라운드를 동기화 원시로 사용. 이 모델은 부분 동기(partial synchorny)를 가정. 여러 시스템이 부분 동기에 의존. 이 연구에서는 부분 동기화 네트워크를 위한 합의 프로토콜(consensus protocol)의 구현에 사용될 수 있는 최적화 원칙을 체계화할 수 있는 프로그래밍 요약이 존재하는지 탐구. 라운드 기반 모델의 요약 수준을 유지하면서도 대형 시스템에서 요구되는 성능을 만족시키는 새로운 라운드 구조를 제공하는 언어닌 RESYNC를 제시.

### Actor concurrency bugs: a comprehensive study on symptoms, root causes, API usages, and differences
행위자 동시성은 널리 사용되고 갈수록 중요해짐. 다중 스레드 동시성과 달리, 행위자 동시성에서는 고수준 개념인 행위자와 메시지를 사용하므로, 경쟁이나 교착 상태와 같은 버그를 일으킬 가능성은 적지만 행위자 동시성만의 또 다른 버그를 일으킴. 기존 연구에서는 행위자 버그의 분류, 테스팅, 디버깅 등을 수행했지만, 행위자 버그의 증상, 근본 원인, API 사용, 예시 등에 대한 연구는 부족. 이 연구에서는 널리 사용되는 행위자 프레임워크인 Akka에 관련된 실제 버그를 수집 및 정리하여 증상, 근본 원인 등을 분류함.

### A structural model for contextual code changes
프로그램은 지속적으로 수정되며 잘못된 수정은 버그, 취약점, 가독성 저하 등의 문제를 일으키므로 올바르게 수정하는 것이 중요. 이 연구에서는 EditCompletion 과제를 제시. 이 과제는 어떤 코드에서 시작되어 부분적으로 이루어진 수정이 주어졌을 때 남은 수정을 완성하는 것. 이는 부분적인 코드가 주어졌을 때 그 코드를 완성하는 과제인 코드 완성 과제와는 다름. 코드 수정을 표현하는 것이 중요. 이 연구에서는 코드를 텍스트로 보고 text-diff 알고리즘을 사용하는 순진한 방법 대신, AST 사이의 차이를 모델링하여 AST 경로로 코드 편집을 나타냄. 코드 편집은 노드 이동이나 업데이트와 같은 수정 연산의 나열로 정의됨. 주어진 경로로부터 남은 경로를 예측하도록 신경망을 학습시킴. 실험 결과 기존 기술보다 더 잘 정확함을 확인.

### Verifying replicated data types with typeclass refinements in Liquid Haskell
Liquid Haskell은 정제 타입을 제공하는 Haskell의 확장으로, 유효한 값의 집합을 제한하는 술어를 타입에 붙이는 것을 허용하고 SMT 해결기를 통해 술어가 자동으로 검사됨. Liquid Haskell은 타입 클래스의 성질을 검증할 수 없다는 한계가 있음. 타입 클래스의 개별 인스턴스의 성질을 증명할 수는 잇지만 타입 클래스 정의에 있는 메서드에 정제 타입을 붙이는 것을 불가능. 이 연구에서는 Liquid Haskell을 확장해 이 한계를 해결. 구현은 Haskell 소스 코드가 아닌 GHC의 중간 표현인 Core의 성질을 검증. 이를 통해 GHC의 기능을 활용할 수 있음. 단, GHC가 타입 클래스를 사전으로 바꾸기 때문에 Core에는 타입 클래스가 없음. 이를 해결하기 위해 타입 클래스 메서드의 정제 타입을 사전에 대한 불변 성질로 변환. 확장된 Liquid Haskell을 사용해 타입 클래스가 타입 클래스 법칙을 만족하는지 검증했으며, 복제된 데이터 타입(replicated data type)도 검증함.

### Unifying execution of imperative generators and declarative specifications
(선언적) 명세는 프로그램의 의도를 나타내고, (절차적) 구현은 그 의도가 어떻게 달성되는지 묘사. 명세를 작성하는 언어의 표현력이 충분하다면 명세가 구현보다 간결. 실행 가능한 계약(executable contract)의 형태로 작성된 프로그램은 명세만으로 프로그램이 정의되므로 읽기 쉽고 오류의 가능성이 적음. 실행 중 계약을 만나면 제약 해결기 등을 사용해 계약을 만족하는 프로그램 힙을 찾아야 하며, 이 과정은 많은 비용이 듦. 이 연구에서는 선언적 명세와 절차적 생성기(generator)를 함께 사용해 계약을 작성하는 새로운 접근 방법인 DEUTERIUM을 제시. 프로그래머가 힙의 객체를 만들고 초기화하는 생성기를 제공할 수 있으며, 이를 사용해 탐색 공간을 가지치기하고 성능 부하를 줄일 수 있음. DEUTERIUM은 새로운 명세 작성 언어인 2H를 제공.

### Regex matching with counting-set automata
정규식 대조는 소프트웨어에서 널리 사용되며, 대조 과정의 성능 문제는 DoS 공격과 같은 심각한 문제를 야기할 수 있음. 성능 문제는 대개 역추적(backtracking)으로 인해 발생하며 최악의 경우 주어진 문자열 길이에 대해 지수적 시간이 필요함. 이 연구에서는 성능 문제의 흔한 원인인 개수 세기 연산(counting operator)을 해결하는 데 초점을 둠. 개수 세기 연산은 (ab){1, 100}과 같이 제한된 회수의 반복을 표현. 이 연구에서는 CsA(counting-set automata)라는 새로운 간결하고 빠른 결정적 유한 오토마타를 제시. CsA는 개수 세기 집합이라 불리는 값들을 저장하는 특수한 레지스터를 가짐. 정규식을 CA(counting automata)로 컴파일하는 새로운 방법과 CA를 CsA로 컴파일하는 방법을 제시.

### Feedback-driven semi-supervised synthesis of program transformations
IDE 등은 공통된 종류의 코드 수정을 자동화하여 개발자들이 코드를 수정하는 것을 도울 수 있음. 수정을 충분히 일반화하지 않으면 거짓 음성(수정되어야 할 곳이 수정되지 않음)이 생기고, 너무 일반화하면 거짓 양성(해서는 안 될 수정을 함)이 생김. 기존 연구는 수정 입출력 예시(수정 전 코드와 수정 후 코드의 쌍)로부터 최대/최소로 일반화해 수정하며, 거짓 양성/음성 문제를 일으킴. 이 연구에서는 준지도 학습(semi-supervised learning)을 사용. 주어진 수정 입출력 예시뿐 아니라 코드에 존재하는 만은 개수의 추가적인 입력 나무를 사용. 피드백 기반 방법을 사용. 각 후보 입력에 대해 첫 단계에서는 반통합(anti-unification)을 계산해 일반화가 가능한지 보고, 둘째 단계에서는 피드백 시스템을 사용해 현재 후보 입력이 수락되어야 하는지 평가.

### Contextual dispatch for function specialization
JIT 컴파일러는 인자의 타입과 같은 불변 성질을 실행 중에 관찰하고 그 불변 성질을 활용하는 코드를 생성해 최적화를 진행. 이 연구에서는 동적 정보를 JIT 컴파일러가 더 잘 활용하도록 문맥에 따른 선택(contextual dispatch)를 제시. 문맥은 프로그램의 상태에 대한 술어로, 문맥 사이에 부분 순서와 극대(maximal) 원소가 존재. 함수의 각 버전은 특정 문맥이 만족된다는 가정하에 컴파일된 함수의 인스턴스. 컴파일러는 함수 호출에 대해 호출부의 문맥을 계산하고 해당 문맥에 가장 가깝게 일치하는 버전을 호출하는 코드를 생성. Ř 가상 기계에 개념 증명 구현을 추가하고 최적화가 얼마나 성능에 기여하는지 평가함.

### Counterexample-guided correlation algorithm for translation validation
번역 확인(translation validation)은 매 컴파일 결과를 검증하는 것으로, 모든 입력에 대한 올바름이 확인된 컴파일러인 검증된 컴파일러와는 다른 접근 방법. 이미 존재하는 컴파일러에 대해 사용될 수 있다는 것이 장점. 자동 번역 확인은 두 프로그램(소스와 어셈블리)의 변수 사이의 귀납적 관계적 불변 성질을 찾는 것을 통해 이루어짐. 각 프로그램의 CFG로부터 곱 CFG(product-CFG)를 만들 수 있으며, 곱 CFG에서 불변 성질을 추론해야 함. 한 프로그램 쌍에 대해 곱 CFG는 여럿 존재. 불변 성질 추론 알고리즘을 고정한다면 올바른 곱 CFG를 찾는 것이 중요. 곱 CFG에 대한 몇 가지 관찰을 바탕으로 곱 CFG 탐색 공간을 가지치기할 수 있음. 이 연구에서는 올바른 곱 CFG 찾기위해 효율적으로 탐색하는 반례 유도(counterexample-guided) 알고리즘을 제시.

### Adding interactive visual syntax to textual code
코드는 개발자의 생각을 표현하며, 많은 프로그래밍 문제는 표, 계층 구조, 나무, 숲, 그래프 등과 같은 기하학적 생각을 요구함. 이런 기하학적 생각을 선형 코드로부터 읽어 내기는 어려움. 기존 연구의 시각적 언어(visual language)는 고정된 구성체(construct)만 제공하므로 문제에 특화된 기하학적 생각을 잘 다루지 못하는 한계가 있음. 또, 개발자는 시각적 언어보다 텍스트 언어를 선호하므로 시각적 문법은 텍스트 문법을 대체하기보다는 보조해야 함. 이 연구에서는 텍스트 언어를 원하는 특정 도메인에 적합한 상호작용이 가능하고 시각적인 구성체를 통해 확장하는 메커니즘을 제시.

### Revisiting iso-recursive subtyping
재귀적 타입은 중요한 개념. Amber 규칙은 재귀적 타입의 서브타입을 정의하는 데 널리 사용됨. Amber 규칙은 𝛼 <: 𝛽를 가정했을 때 A <: B를 증명할 수 있다면 𝜇𝛼.A <: 𝜇𝛽.B가 증명된다는 규칙. 동치 재귀적 타입의 서브타입에 대한 선언적 정의(무한히 펼쳤을 때 서브타입이면 서브타입)가 존재하는 것과 달리, 동형 재귀적 타입의 서브타입에 대한 선언적 정의는 잘 탐구되지 않았으며, 동형 재귀적 타입을 위한 Amber 규칙의 메타 이론은 잘 정립되지 않음. 이 연구에서는 Amber 방식 동형 재귀적 타입의 서브타입의 정신을 잘 표현하는 선언적 정의(모든 유한한 펼침이 서브타입이면 서브타입)를 제시하고 Amber 규칙이 이 명세에 대해 건전함을 증명. 서브타입 여부를 검사하는 건전하고 완전하고 결정적인 알고리즘을 제시.

### Guiding dynamic programing via structural probability for accelerating programming by example
PBE(예시를 통한 프로그래밍)는 프로그램 합성의 중요 문제이나 여전히 확장성(scalability) 문제가 있음. 탐색 공간이 넓기 때문에 해를 찾는 데 오래 걸림. 기존 연구에서는 동적 프로그래밍을 통해 이 문제에 접근. 합성 문제를 여러 작은 프로그램을 합성하는 부분 문제로 나누고 부분 문제에 대한 해를 재활용. 또 다른 기존 연구에서는 a - 1 + 2와 같은 사용되지 않을 것 같은 프로그램을 거르기 위해 구조적 확률을 사용. 이 연구에서는 동적 프로그래밍과 구조적 확률을 모두 활용해 PBE를 효율적으로 해결하는 프레임워크인 MaxFlash를 제시. 첫 번째 어려움은 부분 문제의 지역성과 구조적 확률의 전역성 사이의 간극을 좁히는 것. 이를 위해 부분 문제에 문맥과 확률 하한이라는 매개변수를 추가. 두 번째는 부분 문제의 재활용 기회를 높이는 것. 이를 위해 탐색 문제를 최대 확률의 프로그램을 찾는 최적화 문제로 바꿈.

### Neural reverse engineering of stripped binaries using augmented control flow graphs
이진 실행 파일을 역공학하는 일은 여러 활용처가 있으나 어렵고 많은 시간을 필요로 함. 이진 실행 파일은 대개 프로시저 이름을 포함하는 디버그 정보가 완전히 제거되어 있음. 이로 인해 역공학 과정에서 각 프로시저를 공부한 뒤 이름을 수작업을 붙임. 최근 연구에서는 학습된 모델을 통한 소스 코드 분석에 많은 발전이 있었지만, 실행 파일 고유의 어려움을 다룬 연구는 없음. 이 연구에서는 이름 없는 어셈블리 프로시저가 주어졌을 때 그럴싸한 설명을 제공하는 이름을 추측하는 모델을 만드는 것을 목표로 함. 매우 적은 문법적 정보만 코드에 남아 있고 프로시저 이름이 보통 길기 때문에 어려움. 어셈블리 코드로부터 CFG를 만든 뒤 호출부 구조를 재건하고 포인터 민감 슬라이싱(pointer-aware slicing)을 통해 호출부 데이터를 증가(augment)시킨 후 증가된 호출부 그래프를 만듦으로써 프로시저에 대한 새로운 표현을 만들고 신경망 모델에서 사용.

### Foundations of empirical memory consistency testing
대부분의 현대 언어와 아키텍처에서 완화된 메모리 모델을 사용. 프로그래밍 언어는 관계적 완회된 메모리 모델을 명시하며 프로그래밍 언어 구현이 그 명세를 따르는지 확인해야 함. 이를 위해 정형 증명과 실증적 테스팅이 사용됨. 리트머스 테스트는 오직 하나의 결과만이 완화된 동작에 대응되는 테스트로, 버그를 찾기 위해 많은 회수의 실행이 필요. 이 연구에서는 재현성, 근사된 거짓 음성, 반복된 테스팅 시간을 부족한 점으로 지적. 이 연구에서는 GPU에 대한 실증적 메모리 모델 테스팅 방법을 탐구. 서로 다른 스트레스 매개변수에 따른 결과의 특성을 찾고, 스트레스 매개변수를 효율적으로 조절하고 일반화하는 방법을 제시.

### Just-in-time learning for bottom-up enumerative synthesis
프로그램 합성의 어려움은 합성기가 탐색해야 할 공간이 넓다는 것. 최근 연구에서는 학습된 확률 모델을 사용해 어떤 연산이나 구조가 해에 등장할 가능성이 높은지 추측함으로써 탐색해야 할 공간을 줄임. 두 가지 문제는 유용한 확률 모델을 얻는 방법과 모델이 주어졌을 때 탐색을 유도하는 방법. 기존 연구에서는 문제 도메인에 맞게 주어진 높은 품질의 학습 데이터를 사용해 모델을 만들었으며, 그런 데이터는 일반적으로 얻기 어려움. 이 연구에서는 실시간 학습(just-in-time learning)이라는 새로운 기술을 제시. 주어진 입출력 예시의 일부분을 만족하는 부분 해가 문법적으로 최종 해와 비슷한 경우가 많다는 관찰을 바탕으로 탐색 도중 발견한 부분 해에 등장한 연산의 확률을 높이는 방식으로 작동. 기존 연구에서는 A\* 알고리즘을 통한 가중치 나열 탐색을 하향식 탐색에 사용. 이 연구에서는 유도된 상향식 탐색(guided bottom-up search)이라는 새로운 기술을 제시해 실시간 학습이 부분 해를 빠르게 모을 수 있게 함.

### Gradual verification of recursive heap data structures
Hoare 논리나 분리 논리를 사용해 프로그램을 검증하려면 개발자가 충분한 명세를 제공해야 하며, 간단한 프로그램에서도 필요한 명세의 길이는 프로그래머가 관심 가지는 성질에 대한 명세보다 두 배 이상 김. 이를 해결하고자 기존 연구에서는 점진적 검증을 제안. 점진적 검증은 점진적 타입, 특히 점진적 타입 요약하기에 기반. 점진적 검증기는 정적으로 부정확한 명세의 강화를 가정하고, 건전성을 보장하기 위해 부분 명세가 강화될 때 동적 검사가 추가됨. 기존 연구의 한계는 재귀적 힙 자료 구조의 명세를 지원하지 않는다는 것. 이 연구에서는 그 한계를 극복. 부정확한 명세는 힙 위치의 소유권을 나타내는 술어를 통해 강화될 수 있다는 점과 그런 술어들을 동적으로 검증해야 한다는 점이 어려움.

### Macros for domain-specific languages
매크로는 60 년 가까이 사용되어 온 언어 확장 메커니즘. 매크로는 사용자에게 원하는 기능을 추가할 권한을 줌으로써 DSL 구현에 중요한 역할을 함. 현존하는 매크로 체계는 DSL이 주인 언어(host language)의 확장성을 물려받을 수 있는 메커니즘을 제공하지 않음. 이 연구에서는 최초로 DSL이 주인 언어의 매크로 확작성을 물려받을 수 있는 구조를 제시. 연구의 핵심은 DSL 작성자가 주인 언어에 있는 매크로 팽창기의 필수적 부분들을 재사용할 수 있게 하는 API. DSL 작성자가 위생적 매크로(hygienic macro)의 복잡함을 신경 쓸 필요 없게 하고 DSL이 주인 언어와 자연스럽게 상호 작용한다는 장점이 있음.

### Learning-based controlled concurrency testing
동시성 버그는 찾기 어려움. CCT(controlled concurrency testing)는 스케줄러가 동시성 버그를 발견할 가능성이 높은 흥미로운 탐색 공간을 우선시하도록 만드는(문맥 교환의 수 제한, 순서 제약 수 제한, 지연 추가 등) 기술. 기존의 CCT는 휴리스틱에 의존하므로 특정 버그 패턴에 맞추어져 있어 그 패턴을 벗어나는 버그는 잘 찾지 못함. 이 연구에서는 강화 학습 기술을 적용해 CCT를 개선. CCT 스케줄러가 강화 학습 에이전트이고 프로그램이 강화 학습 환경. 스케줄러가 다음에 실행될 워커를 결정하면 이에 따라 프로그램이 실행되어 상태가 변화. 고전적인 Q 학습 알고리즘을 사용함.

### TacTok: semantics-aware proof synthesis
Coq 증명 스크립트를 작성하는 것은 어려우며 높은 전문성을 요구. 통계적 코드 완성 도구로부터 영감을 얻어, 기존 연구에서는 Coq 증명 스크립트 합성 기술을 제시. Coq 증명이 어느 정도 예측 가능한 토큰의 나열이라는 것을 관찰함. 또한, 프로그래머는 증명을 작성할 때 증명 상태(증명 보조 도구가 제공하는 피드백)를 참고. 이를 바탕으로 기존 연구에서는 프로그래머가 작성한 부분적인 증명 스크립트로부터 남은 부분을 합성하거나 증명 상태로부터 남은 부분을 합성하는 기술을 제시했지만, 두 정보를 동시에 사용하지 않음. 이 연구에서는 부분 증명 스크립트와 증명 상태를 모두 사용하는 합성 기술 TakTok을 제시. 모델을 바탕으로 증명 스크립트 공간을 탐색하는 메타휴리스틱 탐색 전략 세 가지를 새로 제시. 실험적으로 TakTok이 기존 기술보다 더 많은 정리의 증명을 합성함을 확인함.

### Koord: a language for programming and verifying distributed robotics application
분산 로봇 프로그래밍은 중요하지만 어려움. 하드웨어 플랫폼 독립적인 성질인, 동시성과 비동기성하의 조정(coordination) 알고리즘의 올바름을 확인해야 하고, 플랫폼 의존적인 성질인, 방해와 잡음이 존재할 때의 로봇의 물리적 상호 작용의 올바름을 확인해야 함. 이 연구에서는 두 종류의 논증을 분리하는 언어인 Koord를 제시. Koord는 플랫폼 독립적 로직을 플랫폼 의존적 과제에서 분리하는 요약을 제공. K 프레임워크를 통해 Koord의 실행 가능한 의미를 제공. 

### Flow2Vec: value-flow-based precise code embedding
코드 임베딩은 코드를 저차원 벡터 형태로 표현하는 기술로, 다양한 코드 정적 분석 과제에 존재하는 기계 학습 기술을 적용할 수 있게 함. 기존의 코드 임베딩 연구에서는 코드를 텍스트 토큰의 나열로 보거나, 요약 문법 나무를 사용하거나, 데이터 흐름 그래프를 사용함. 존재하는 접근 방법에는 세 가지 한계가 있음. (1) 프로시저 내(intraprocedural) 정보만 사용. (2) 별명 둔감(alias-unaware). (3) 비대칭적 추이성을 무시. 이 연구에서는 최초로 프로시저 간(interprocedural) 별명 민감 값 흐름의 비대칭적 추이성을 보존하는 코드 임베딩인 Flow2Vec을 제시. Flow2Vec은 네 단계로 구성. (a) 사전 임베딩(pre-embedding) (b) 행렬 곱을 통한 값 흐름 도달 가능성 (c) 고차 접근(high-order proximity) 임베딩 (d) 적용.
