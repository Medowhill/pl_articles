**아래 내용은 인사이트 출판사의 제안으로 작성 중인 책의 초고입니다. 실제 출판 시에는 내용이 달라질 수 있습니다. 많은 의견 부탁드립니다.**

여러 값들이 모여 하나의 복잡한 값을 구성하는 또 다른 예시는 맵(map)이다. 맵은 유한한 개수의 열쇠와 값의 쌍을 나열해 만들어진 값이다. 리스트와 달리 맵은 원소 사이의 순서가 중요하지 않으며, 한 맵에 같은 열쇠가 두 번 이상 나올 수 없으나 서로 다른 열쇠에 같은 값이 대응될 수는 있다.

열쇠가 v1부터 vn이며 각 열쇠에 대응되는 값은 v1'부터 vn'인 맵을 { v1 -> v1', …, vn -> vn' }이라 쓰겠다. 예를 들면 { 1 -> 4, false -> 0 }이라는 맵에서는 1과 false가 열쇠이며 1에 대응되는 값은 4, false에 대응되는 값은 0이다.

리스트의 경우와 비슷하게, 맵을 생성하는 식과 맵을 사용하는 식이 있다.

* 맵 생성
  - 문법: `{ e1 -> e1', …, en -> en' }`
  - 의미: e1과 e1'부터 en과 en'까지 차례대로 계산한다. ei의 결과를 vi, ei'의 결과를 vi'라 할 때 { v1 -> v1', …, vn -> vn' }이 최종 결과이다.
* 맵 사용
  - 문법: `e1{e2}`
  - 의미: e1과 e2를 차례로 계산한다. e1의 결과가 맵이고 e2의 결과가 v2이면 그 맵에서 열쇠 v2에 대응되는 값이 최종 결과이다.

{ 1 -> 2 + 2, if true false true -> 0 }을 계산한 결과는 { 1 -> 4, false -> 0 }이다. 또한, { 1 -> 2 + 2, if true false true -> 0 }{ 1 + 0 }의 결과는 열쇠 1에 대응되는 값인 4이다.

레코드(record)는 맵과 유사한 형태의 값이다. 맵과 레코드의 관계는 리스트와 튜플의 관계와 상당히 비슷하다. 맵에서는 임의의 값이 열쇠로 사용될 수 있지만, 레코드에서는 값 대신 이름이 열쇠로 사용된다. 레코드에서 열쇠 역할을 하는 이름을 필드(field)라고 부른다. 맵과 마찬가지로 레코드에서도 순서가 중요하지 않으며 필드는 겹칠 수 없지만 서로 다른 두 필드에 같은 값이 대응될 수 있다.

필드가 x1부터 xn이며 각 열쇠에 대응되는 값은 v1부터 vn인 레코드를 { x1: v1, …, xn: vn }이라 쓰겠다. 예를 들면 { a: 3, b: true }이라는 레코드에서는 a와 b가 열쇠이며 a에 대응되는 값은 3, b에 대응되는 값은 true이다.

레코드는 맵과 비슷한 방법으로 만들 수 있다.

* 레코드 생성
  - 문법: `{ x1: e1, …, xn: en }`
  - 의미: e1부터 en까지 차례대로 계산한다. ei의 결과를 vi라 할 때 { x1: v1, …, xn: vn }이 최종 결과이다.

{ a: 1 + 2, b: true }의 결과는 { a: 3, b: true }이다.

맵의 열쇠는 값이므로 임의의 식을 계산한 결과를 맵 안에 있는 값을 얻는 데 사용할 수 있었다. 그러나 레코드의 필드는 이름이며, 식을 계산한 결과가 이름이 될 수는 없다. 레코드에 있는 필드의 값을 얻으려면 해당 필드의 이름을 직접 쓰는 수밖에 없다.

* 레코드 사용
  - 문법: `e.x`
  - 의미: e를 계산한다. e의 결과가 레코드이면 그 레코드의 필드 x에 대응되는 값이 최종 결과이다.

{ a: 1 + 2, b: true }.a의 결과는 3이다.

열쇠의 개수가 정해져 있지 않거나, 어느 열쇠에 접근해야 할지 알 수 없을 때는 맵을 사용한다. 예를 들면, 어떤 학급에 속한 학생들의 키는 이름이 열쇠이고 키가 값인 맵을 사용해 표현할 수 있다. 학생이 몇 명인지 정해져 있지 않고, 사용자가 이름을 입력하면 그 이름을 가진 학생의 키를 출력해야 할 수 있으니, 맵이 합당한 선택이다.

반대로, 열쇠의 개수가 정해져 있고 각 열쇠가 의미하는 바가 고정되어 있을 때는 레코드를 사용한다. 어떤 학생의 이름, 키, 수업료 납부 여부를 레코드로 표현할 수 있다.

```
let student = { name: "Gildong Hong", height: 180, tuition: true }
```

위와 같은 방식으로 학생을 나타낼 수 있으며, 이름이 필요할 때는 student.name, 키를 알고 싶을 때는 student.height, 수업료를 냈는지 확인할 때는 student.tuition을 사용하면 된다.

리스트와 튜플의 관계처럼, 지금은 레코드가 맵에 비해 나은 점이 딱히 보이지 않는다. 레코드의 가치 역시 정적 타입 언어에서 더 잘 드러난다.

객체(object)는 레코드에 자기 자신을 사용할 수 있는 능력을 추가한 것이다. 재귀적인 구조를 가진 레코드라고 표현할 수도 있다. (객체에 대해 다양한 설명이 가능하겠지만, 이 책의 목적은 객체 지향 프로그래밍을 다루는 것이 아니므로 이 정도로만 정의하겠다.) 객체는 필드에 더해 메서드(method)를 가진다. 메서드는 함수처럼 이름, 매개변수, 몸통으로 구성되며 호출될 수 있다. 그러나 함수와 달리 특정 객체에 종속되어 있으며 자신을 소유한 객체에 접근할 수 있다. 메서드가 자신을 소유한 객체에 접근하는 방법은 this라는 식을 사용하는 것이다.

* 객체 접근
  - 문법: `this`
  - 의미: 메서드의 몸통에서만 사용될 수 있다. 해당 메서드를 소유한 객체가 결과이다.

객체는 필드와 메서드 정의를 나열함으로써 만들 수 있다.

* 메서드 정의
  - 문법: `def x(x1, …, xn) = e`

메서드 정의는 식이 아니며 객체를 생성하는 식의 부속품일 뿐이다. 식이 아니므로 의미는 정의되지 않았다. 임의의 메서드 정의를 M이라 쓸 것이다.

* 객체 생성
  - 문법: `{ x1: e1, …, xn: en, M1, …, Mk }`
  - 의미: e1부터 en까지 차례대로 계산한다. 필드 x1부터 xn과 메서드 M1부터 Mk를 가지고 있는 객체가 최종 결과이다. 이때, ei의 결과를 vi라 할 때 필드 xi의 값이 vi이다.

객체를 사용한다는 것은 객체의 필드에 접근하거나 객체가 소유한 메서드를 호출하는 것이다.

* 객체 사용(필드 접근)
  - 문법: `e.x`
  - 의미: e를 계산한다. e의 결과가 객체이면 그 객체의 필드 x에 대응되는 값이 최종 결과이다.
* 객체 사용(메서드 호출)
  - 문법: `e0.x(e1, …, en)`
  - 의미: e0부터 en까지 차례대로 계산한다. e0의 결과가 객체이며 그 객체에 있는 이름이 x인 메서드의 매개변수가 x1부터 xn이고 몸통이 e이면, xi의 값이 ei의 결과인 상태로 e를 계산한다. e의 결과가 최종 결과이다.

```
{ a: 1, def foo(n) = this.a + n, def bar() = this.foo(3) }
```

위 식은 객체를 생성하는 식이다. 이 식을 통해 만들어진 객체는 필드 a와 메서드 foo, bar를 가진다. 필드 a의 값은 1이고, 메서드 foo는 인자를 하나 받아 그 인자와 필드 a가 나타내는 값의 합을 결과로 내며, 메서드 bar는 인자를 받지 않고 메서드 foo를 3에 적용해 얻은 값을 결과로 낸다.

```
let obj = { a: 1, def foo(n) = this.a + n, def bar() = this.foo(3) };
obj.bar()
```

obj.bar()는 obj가 나타내는 객체의 메서드 bar를 호출하며, 메서드 bar의 몸통을 계산하는 중에 같은 객체의 메서드 foo가 호출된다. 메서드 foo의 몸통을 계산하면 필드 a에 접근해 1을 얻은 뒤 1에 인자로 받은 3을 더해 4가 나온다. 따라서 최종 결과는 4이다.

메서드를 호출할 때 호출된 메서드를 소유한 객체를 수신자(receiver)라고 부른다. 예를 들면, obj.bar()에서 obj가 나타내는 객체가 수신자이다.

클래스(class)를 사용해서 비슷하게 생긴 여러 개의 객체를 쉽게 만들 수 있다. 아래의 코드는 매우 장황하다.

```
let obj1 = { a: 1, def foo(n) = this.a + n, def bar() = this.foo(3) };
let obj2 = { a: 10, def foo(n) = this.a + n, def bar() = this.foo(3) };
obj1.bar() + obj2.foo(0)
```

obj1과 obj2가 나타내는 객체는 매우 비슷하다. 필드 a의 값이 1이냐 10이냐의 차이만 있다. 이렇게 비슷한 객체를 만들 때 매번 긴 식을 쓰는 것은 불편하다. 이 문제를 해결해 주는 것이 객체의 설계도인 클래스이다. 클래스를 정의할 때는 객체가 어떤 필드와 메서드를 가지는지 명시한다. 정의한 클래스의 생성자(constructor)를 호출하면 클래스의 정의에 포함된 필드와 메서드를 모두 가지고 있는 객체가 만들어진다. 이렇게 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)라고 부른다.

* 클래스 정의
  - 문법: `class x { x1, …, xn, M1, …, Mk }`
  - 의미: 이름이 x이며 x1부터 xn까지의 필드와 M1부터 Mk까지의 메서드를 가지는 클래스를 정의한다. ()이 최종 결과이다.

* 생성자 호출
  - 문법: `new x(e1, …, en)`
  - 의미: e1부터 en까지 차례대로 계산한다. 클래스 x가 x1부터 xn까지의 필드와 M1부터 Mk까지의 메서드를 가지면, x1부터 xn까지의 필드와 M1부터 Mk까지의 메서드를 가지는 객체가 최종 결과이다. 이때, ei의 결과를 vi라 할 때 필드 xi의 값이 vi이다.

위에서 본 예시를 클래스를 통해 다시 작성해 보겠다.

```
class C {
  a,
  def foo(n) = this.a + n,
  def bar() = this.foo(3)
};
let obj1 = new C(1);
let obj2 = new C(10);
obj1.bar() + obj2.foo(0)
```

객체를 만드는 식이 훨씬 간결해졌다. 클래스 C의 인스턴스를 많이 만들수록 클래스의 이점이 잘 드러날 것이다.

이미 존재하는 클래스를 다른 클래스를 정의하는 데 사용할 수도 있다. 이를 상속(inheritance)이라고 부른다. 클래스 x2가 클래스 x1로부터 상속받는다면 클래스 x1의 모든 필드와 메서드가 클래스 x2에도 정의된다. 이에 더해, 클래스 x2만의 필드와 메서드를 추가로 정의할 수 있다. 새롭게 정의하는 클래스에서 기존 클래스에 있던 메서드 정의를 버리고 새롭게 같은 이름의 메서드를 정의하는 것도 가능하다. 이를 메서드 오버라이딩(overriding)이라고 부른다. 클래스 x2가 클래스 x1로부터 상속받은 경우, 클래스 x1을 클래스 x2의 슈퍼클래스(superclass)라고 부르며 클래스 x2를 클래스 x1의 서브클래스(subclass)라고 부른다.

* 상속을 통한 클래스 정의
  - 문법: `class x extends x' { x1, …, xn, M1, …, Mk }`
  - 의미: x'이 x1'부터 xn''까지의 필드와 M1'부터 Mk''까지의 메서드를 가지는 클래스이면, 이름이 x이며 x1'부터 xn'' 및 x1부터 xn까지의 필드와 M1'부터 Mk'' 및 M1부터 Mk까지의 메서드를 가지는 클래스를 정의한다. 만약 x에 새롭게 정의된 메서드가 x'에 있던 메서드와 이름이 겹친다면 새롭게 정의된 메서드가 기존 메서드를 대체한다. ()이 최종 결과이다.

다음은 상속을 사용하는 코드의 예시이다.

```
class C {
  a,
  def foo(n) = this.a + n,
  def bar() = this.foo(3)
};
class D extends C {
  b,
  def bar() = 0,
  def baz(m) = this.foo(m) + this.b
}
let obj = new D(1, 2);
obj.bar() + obj.baz(3)
```

위 식의 결과는 0, 1, 2, 3의 합인 6이다. D에서 bar는 오버라이딩되었으며 b와 baz는 추가되었다.

일부 언어에서는 여러 클래스로부터 상속받아 새로운 클래스를 만드는 행위인 다중 상속을 허용한다. 이에 반해, 위에서 본 상속은 한 클래스로부터만 상속받는 단일 상속이다. 다중 상속은 기본적으로 단일 상속과 큰 차이가 없기에 따로 다루지 않겠다.
